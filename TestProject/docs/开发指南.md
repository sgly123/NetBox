# 🔧 TestProject 开发指南

欢迎使用NetBox框架进行二次开发！本指南将帮助你快速上手框架的扩展开发。

## 📋 **框架架构**

TestProject基于NetBox框架构建，采用分层架构设计：

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (Application Layer)                │
│  - Web应用  - 游戏应用  - 微服务应用  - 自定义应用           │
├─────────────────────────────────────────────────────────────┤
│                    协议层 (Protocol Layer)                   │
│  - HTTP协议  - WebSocket  - 自定义协议  - 消息编解码         │
├─────────────────────────────────────────────────────────────┤
│                    网络层 (Network Layer)                    │
│  - 传输层抽象  - 连接管理  - 负载均衡  - 网络优化           │
├─────────────────────────────────────────────────────────────┤
│                    插件层 (Plugin Layer)                     │
│  - 认证插件  - 缓存插件  - 数据库插件  - 监控插件           │
├─────────────────────────────────────────────────────────────┤
│                    核心层 (Core Layer)                       │
│  - 事件循环  - 线程池  - 内存管理  - 配置管理               │
└─────────────────────────────────────────────────────────────┘
```

## 🚀 **快速开始**

### **1. 构建框架**
```bash
cd TestProject
mkdir build && cd build
cmake ..
make -j$(nproc)
```

### **2. 运行示例**
```bash
# 基础TCP服务器示例
./examples/simple_server

# 自定义协议示例
./examples/custom_protocol
```

### **3. 运行测试**
```bash
make test
```

---

## 🔌 **协议层二次开发**

### **实现自定义协议**

1. **继承Message基类**
```cpp
class MyMessage : public NetBox::Protocol::Message {
    // 实现序列化和反序列化
    std::vector<uint8_t> serialize() const override;
    bool deserialize(const std::vector<uint8_t>& data) override;
};
```

2. **实现Codec编解码器**
```cpp
class MyCodec : public NetBox::Protocol::Codec {
    std::vector<uint8_t> encode(const Message& message) override;
    bool decode(const std::vector<uint8_t>& data, std::unique_ptr<Message>& message) override;
    int checkIntegrity(const std::vector<uint8_t>& data) override;
};
```

3. **实现ProtocolHandler处理器**
```cpp
class MyProtocolHandler : public NetBox::Protocol::ProtocolHandler {
    void onMessage(std::shared_ptr<Message> message) override;
    void onConnect() override;
    void onDisconnect() override;
};
```

4. **创建ProtocolFactory工厂**
```cpp
class MyProtocolFactory : public NetBox::Protocol::ProtocolFactory {
    std::unique_ptr<Codec> createCodec() override;
    std::unique_ptr<ProtocolHandler> createHandler() override;
    std::string getProtocolName() const override;
};
```

### **协议扩展示例**

参考 `examples/custom_protocol/custom_protocol.cpp` 查看完整的自定义协议实现。

---

## 🎯 **应用层二次开发**

### **Web应用开发**

1. **继承WebApplication**
```cpp
class MyWebApp : public NetBox::Application::WebApplication {
public:
    MyWebApp() : WebApplication("MyWebApp") {}

    bool initialize() override {
        // 设置路由
        addRoute("GET", "/api/users", [](auto ctx) {
            ctx->send("{\"users\": []}");
        });

        // 设置静态文件服务
        serveStatic("/static", "./public");

        return true;
    }
};
```

2. **自定义中间件**
```cpp
addMiddleware([](std::shared_ptr<Context> ctx) -> bool {
    // 认证中间件
    std::string token = ctx->getAttribute("Authorization");
    if (token.empty()) {
        ctx->send("HTTP/1.1 401 Unauthorized\r\n\r\n");
        return false; // 阻止继续处理
    }
    return true; // 继续处理
});
```

### **游戏应用开发**

1. **继承GameApplication**
```cpp
class MyGameServer : public NetBox::Application::GameApplication {
public:
    MyGameServer() : GameApplication("MyGameServer") {}

    void onPlayerJoin(std::shared_ptr<Context> ctx) override {
        std::string playerId = generatePlayerId();
        ctx->setAttribute("playerId", playerId);
        broadcastMessage("Player " + playerId + " joined");
    }

    void onGameMessage(std::shared_ptr<Context> ctx, const std::string& message) override {
        // 处理游戏消息
        processGameLogic(ctx, message);
    }
};
```

---

## 🌐 **网络层二次开发**

### **自定义传输层**

1. **实现Transport接口**
```cpp
class MyTransport : public NetBox::Network::Transport {
public:
    bool bind(const std::string& address, int port) override;
    bool listen(int backlog) override;
    std::shared_ptr<Transport> accept() override;
    int send(const std::vector<uint8_t>& data) override;
    int receive(std::vector<uint8_t>& data) override;
};
```

### **网络优化器**

1. **实现Optimizer接口**
```cpp
class MyOptimizer : public NetBox::Network::Optimizer {
public:
    void optimizeConnection(std::shared_ptr<Transport> transport) override {
        // 设置TCP_NODELAY
        transport->setOption("TCP_NODELAY", "1");

        // 设置缓冲区大小
        transport->setOption("SO_RCVBUF", "65536");
        transport->setOption("SO_SNDBUF", "65536");
    }

    void optimizeTransfer(std::vector<uint8_t>& data) override {
        // 数据压缩
        compressData(data);
    }
};
```

### **负载均衡器**

1. **实现LoadBalancer接口**
```cpp
class MyLoadBalancer : public NetBox::Network::LoadBalancer {
private:
    std::vector<Backend> m_backends;
    size_t m_currentIndex = 0;

public:
    std::pair<std::string, int> selectBackend() override {
        // 轮询算法
        if (m_backends.empty()) return {"", 0};

        auto& backend = m_backends[m_currentIndex];
        m_currentIndex = (m_currentIndex + 1) % m_backends.size();

        return {backend.address, backend.port};
    }
};
```

---

## 🔌 **插件系统开发**

### **认证插件**

```cpp
class JWTAuthPlugin : public NetBox::Plugins::AuthPlugin {
public:
    std::string getName() const override { return "JWTAuth"; }
    std::string getVersion() const override { return "1.0.0"; }

    bool authenticate(const std::string& username, const std::string& password) override {
        // 验证用户名密码
        return validateCredentials(username, password);
    }

    std::string generateToken(const std::string& username) override {
        // 生成JWT令牌
        return createJWTToken(username);
    }

    bool validateToken(const std::string& token) override {
        // 验证JWT令牌
        return verifyJWTToken(token);
    }
};
```

### **缓存插件**

```cpp
class RedisCache : public NetBox::Plugins::CachePlugin {
private:
    RedisConnection m_redis;

public:
    bool initialize() override {
        return m_redis.connect("localhost:6379");
    }

    bool set(const std::string& key, const std::string& value, int ttl) override {
        if (ttl > 0) {
            return m_redis.setex(key, ttl, value);
        } else {
            return m_redis.set(key, value);
        }
    }

    std::string get(const std::string& key) override {
        return m_redis.get(key);
    }
};
```

---

## 📊 **性能优化指南**

### **1. 网络层优化**
- 使用合适的IO多路复用模型 (EPOLL/KQUEUE/IOCP)
- 调整TCP参数 (TCP_NODELAY, SO_REUSEPORT)
- 实现连接池和对象池
- 使用零拷贝技术

### **2. 协议层优化**
- 设计高效的序列化格式
- 实现消息压缩
- 使用批量处理
- 避免频繁的内存分配

### **3. 应用层优化**
- 异步处理长时间操作
- 实现请求缓存
- 使用数据库连接池
- 优化业务逻辑

---

## 🧪 **测试指南**

### **单元测试**
```cpp
#include <gtest/gtest.h>
#include "MyProtocol.h"

TEST(MyProtocolTest, MessageSerialization) {
    MyMessage msg;
    msg.setData("test data");

    auto serialized = msg.serialize();
    EXPECT_GT(serialized.size(), 0);

    MyMessage decoded;
    EXPECT_TRUE(decoded.deserialize(serialized));
    EXPECT_EQ(decoded.getData(), msg.getData());
}
```

### **集成测试**
```cpp
TEST(IntegrationTest, ServerClientCommunication) {
    // 启动服务器
    MyServer server;
    ASSERT_TRUE(server.start("localhost", 8080));

    // 连接客户端
    MyClient client;
    ASSERT_TRUE(client.connect("localhost", 8080));

    // 发送消息
    client.send("Hello Server");

    // 验证响应
    auto response = client.receive();
    EXPECT_EQ(response, "Hello Client");
}
```

---

## 📚 **API参考**

### **核心类**
- `NetBox::Framework` - 框架主类
- `NetBox::EventLoop` - 事件循环
- `NetBox::ThreadPool` - 线程池

### **网络类**
- `NetBox::Network::Transport` - 传输层接口
- `NetBox::Network::Connection` - 连接管理
- `NetBox::Network::Server` - 服务器基类

### **协议类**
- `NetBox::Protocol::Message` - 消息基类
- `NetBox::Protocol::Codec` - 编解码器接口
- `NetBox::Protocol::ProtocolHandler` - 协议处理器

### **应用类**
- `NetBox::Application::Application` - 应用基类
- `NetBox::Application::WebApplication` - Web应用基类
- `NetBox::Application::GameApplication` - 游戏应用基类

---

## 🤝 **贡献指南**

1. **Fork项目**
2. **创建特性分支** (`git checkout -b feature/AmazingFeature`)
3. **提交更改** (`git commit -m 'Add some AmazingFeature'`)
4. **推送分支** (`git push origin feature/AmazingFeature`)
5. **创建Pull Request**

---

## 📄 **许可证**

本项目采用MIT许可证 - 查看 [LICENSE](LICENSE) 文件了解详情。

---

## 🆘 **获取帮助**

- 📖 查看 [API文档](api/README.md)
- 💬 加入 [讨论区](https://github.com/TestProject/discussions)
- 🐛 报告 [问题](https://github.com/TestProject/issues)
- 📧 联系维护者: developer@netbox.com

---

**开始你的NetBox二次开发之旅吧！** 🚀
