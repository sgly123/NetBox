# 协议层改进设计

## 改进概述

基于你的反馈，我们重新设计了协议层，使其更好地符合协议层的核心职责：
- **拆包**：从原始流数据中提取完整业务包
- **封包**：将业务数据打包成协议格式
- **流量控制**：控制发送/接收速率
- **回调接口**：通过回调将数据交给上层业务处理

## 核心改进

### 1. 职责明确的接口设计

#### 新的ProtocolBase接口
```cpp
class ProtocolBase {
public:
    // 回调函数类型
    using PacketCallback = std::function<void(const std::vector<char>&)>;
    using ErrorCallback = std::function<void(const std::string&)>;
    
    // 核心接口
    virtual size_t onDataReceived(const char* data, size_t len) = 0;  // 拆包
    virtual bool pack(const char* data, size_t len, std::vector<char>& out) = 0;  // 封包
    
    // 回调设置
    void setPacketCallback(PacketCallback callback);
    void setErrorCallback(ErrorCallback callback);
    
    // 流量控制
    virtual void setFlowControl(size_t maxReceiveRate = 0, size_t maxSendRate = 0);
    
    // 状态管理
    virtual void reset() = 0;
};
```

### 2. 完整的拆包功能

#### 解决粘包/半包问题
- **内部缓冲区**：协议层维护接收缓冲区
- **循环处理**：持续从缓冲区中提取完整包
- **状态管理**：正确处理不完整的数据

```cpp
size_t SimpleHeaderProtocol::onDataReceived(const char* data, size_t len) {
    // 添加到缓冲区
    buffer_.insert(buffer_.end(), data, data + len);
    
    // 循环处理完整包
    while (buffer_.size() >= 4) {
        uint32_t bodyLen = parseHeader();
        if (buffer_.size() < 4 + bodyLen) break;  // 数据不足
        
        // 提取完整包并调用回调
        extractPacket(bodyLen);
    }
}
```

### 3. 流量控制机制

#### 速率限制
- **接收速率控制**：防止接收缓冲区溢出
- **发送速率控制**：防止网络拥塞
- **时间窗口**：基于1秒滑动窗口的统计

```cpp
bool checkFlowControl(size_t bytes) {
    size_t currentTime = getCurrentTime();
    
    // 检查接收速率
    if (maxReceiveRate_ > 0) {
        if (currentTime - lastReceiveTime_ >= 1000) {
            receiveBytes_ = 0;  // 重置计数器
        }
        if (receiveBytes_ + bytes > maxReceiveRate_) {
            return false;  // 超过限制
        }
    }
    return true;
}
```

### 4. 回调接口设计

#### 业务层解耦
- **数据包回调**：当拆出完整包时调用
- **错误回调**：当发生协议错误时调用
- **异步处理**：协议层不阻塞业务逻辑

```cpp
// 业务层设置回调
protocol.setPacketCallback([](const std::vector<char>& packet) {
    // 处理完整的数据包
    handleBusinessLogic(packet);
});

protocol.setErrorCallback([](const std::string& error) {
    // 处理协议错误
    logError(error);
});
```

## 使用示例

### C++版本
```cpp
#include "Protocol/include/SimpleHeaderProtocol.h"

int main() {
    // 创建协议实例
    SimpleHeaderProtocol protocol;
    
    // 设置回调
    protocol.setPacketCallback(onPacketReceived);
    protocol.setErrorCallback(onProtocolError);
    
    // 设置流量控制
    protocol.setFlowControl(1024, 1024);  // 1KB/s
    
    // 处理接收数据
    char data[] = "Hello";
    size_t processed = protocol.onDataReceived(data, strlen(data));
    
    // 封包发送数据
    std::vector<char> packet;
    protocol.pack("Response", 8, packet);
}
```

### Python版本
```python
from improved_protocol import SimpleHeaderProtocol, FlowControlConfig

# 创建协议实例
flow_control = FlowControlConfig(max_receive_rate=1024, max_send_rate=1024)
protocol = SimpleHeaderProtocol(flow_control)

# 设置回调
protocol.set_packet_callback(on_packet_received)
protocol.set_error_callback(on_protocol_error)

# 处理数据
processed = protocol.on_data_received(b"Hello")
packet = protocol.pack(b"Response")
```

## 测试功能

### 1. 正常拆包测试
- 验证完整包的拆包功能
- 检查回调函数调用

### 2. 粘包处理测试
- 多个包连在一起的情况
- 验证正确分离多个包

### 3. 半包处理测试
- 数据不完整的情况
- 验证缓冲区管理

### 4. 流量控制测试
- 速率限制功能
- 超限处理

### 5. 错误处理测试
- 包大小超限
- 损坏数据处理

## 编译和运行

### C++版本
```bash
# 编译
mkdir -p build && cd build
cmake ..
make

# 运行测试
./protocol_test
```

### Python版本
```bash
# 运行测试
python3 improved_protocol.py
```

## 架构优势

1. **职责分离**：协议层专注于协议处理，业务层专注于业务逻辑
2. **可扩展性**：易于添加新的协议实现
3. **健壮性**：完善的错误处理和流量控制
4. **性能优化**：高效的缓冲区管理和内存使用
5. **易于测试**：清晰的接口和回调机制

## 后续扩展

1. **更多协议类型**：WebSocket、HTTP、自定义协议
2. **高级流量控制**：令牌桶、漏桶算法
3. **协议压缩**：支持数据压缩
4. **加密支持**：协议层加密/解密
5. **性能监控**：协议层性能统计 