# NetBox
<<<<<<< HEAD

## 一。需求分析

### 1.1 功能概述

该框架是面向 Linux 环境的**模块化高性能网络通信框架**，核心目标是通过黑盒封装降低使用门槛，同时满足高并发、低延迟场景需求。具体功能包括：

- **I/O 模型**：基于 Reactor 模式实现非阻塞 I/O（采用**单 Reactor + 多线程 I/O 池**的 MVP 设计，主线程负责 epoll 事件监听与连接建立，从线程池处理数据读写，后续可扩展为多 Reactor 模型提升并发）。
- **连接管理**：内置连接池（支持空闲连接超时回收，默认 60s，可配置）、心跳检测（固定 10s 间隔，断线自动标记），支持 100w + 长连接的创建、销毁与状态维护。
- **多线程调度**：分离 I/O 线程池（处理网络读写）与业务线程池（执行用户回调），避免 I/O 阻塞影响业务逻辑，线程数可通过配置指定（默认 = CPU 核心数 * 2）。
- **黑盒接口**：对外暴露极简 API（初始化、启动、注册回调、发送消息），隐藏 epoll、协议解析等底层细节，用户无需关注实现逻辑。

### 1.2 性能指标

#### 核心性能目标**并发连接**：单机稳定支持 1w + 长连接（后续通过连接池复用、内存池优化扩展至 10w+）。

- **处理能力**：单机 QPS ≥ 10w（基于 100 字节小消息压测）。
- **响应延迟**：平均消息处理延迟 < 1ms（从接收消息到调用业务回调的耗时）。

#### 非功能约束

- **资源占用**：1w 连接时内存占用 < 500MB，CPU 使用率峰值 < 70%（避免系统卡顿）。
- **可靠性**：支持消息 “至少一次” 交付（通过重传机制避免丢失，MVP 阶段暂不保证 “恰好一次”），单线程崩溃不影响整体服务（核心模块隔离）。

### 1.3 网络协议支持

采用**模块化协议设计**，支持协议动态注册（黑盒内通过接口抽象实现），当前 MVP 阶段优先实现：

- **TCP**：用于可靠长连接场景（如游戏客户端 - 服务器通信），默认处理粘包（基于 “4 字节长度 + 包体” 的自定义协议）。
- **自定义二进制协议**：极简格式（包头含协议类型标识），降低解析开销，适配实时数据传输（如直播弹幕）。
- **扩展规划**：后续通过实现协议接口，可添加 WebSocket（用于浏览器 - 服务器实时通信）、HTTP（用于微服务接口调用）。

### 1.4 适用场景及差异化需求

针对不同场景的核心诉求设计适配方案，体现框架的针对性：

- **游戏服务器数据通信**：需低延迟（<1ms）、消息有序性（避免战斗指令乱序）、断线重连后快速恢复状态（连接上下文缓存 30s）。
- **微服务数据通信**：需高可用（单节点故障不影响整体，支持连接迁移）、流量控制（内置简单限流，避免下游服务过载）。
- **实时数据传输（如弹幕、IoT 数据）**：需高吞吐（支持批量消息合并发送）、容忍短暂消息堆积（堆积上限 1w 条 / 连接）。

## 二。架构设计

采用**分层松耦合设计**，各模块通过接口交互（黑盒边界），确保替换底层实现不影响上层使用。

### 2.1 分层架构（核心模块）

![image](file:///D:/%5CDesktop%5C%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%AE%BE%E8%AE%A1.png)

#### （1）网络 I/O 模块（底层黑盒）

- **核心职责**：管理 TCP 连接生命周期、处理 epoll 事件、执行数据收发。
- **内部实现**：epoll LT 模式（MVP 阶段简化，后续可升级为 ET 模式提升效率）、连接上下文（存储 fd、地址、缓冲区等）、I/O 线程池（绑定 CPU 核心，减少调度开销）。
- **黑盒接口**：提供`start()`（启动服务）、`send()`（发送数据）、`registerConnectionCallback()`（注册连接事件回调）。

#### （2）协议处理模块（可插拔黑盒）

- **核心职责**：解析 / 封装协议数据，解决 TCP 粘包问题。
- **实现方式**：通过`Protocol`抽象类定义接口（`encode()`/`decode()`），自定义协议为默认实现（包头 + 包体），后续可通过实现接口扩展 HTTP/WebSocket。
- **黑盒接口**：用户无需调用，框架内部自动调用协议模块完成数据转换。

#### （3）应用层模块（用户交互黑盒）

- **核心职责**：提供业务接入入口，隔离网络逻辑与业务逻辑。

- 核心接口

  ：

  - `init()`：初始化框架（指定端口、线程数、协议类型）。
  - `registerMessageCallback()`：注册消息处理函数（用户只需关注 “收到消息后执行什么逻辑”）。
  - `getConnectionCount()`：获取当前连接数（监控基础指标）。

### 2.2 核心组件交互流程（示例）

以 “客户端发送消息到业务处理” 为例：

1. 网络 I/O 模块通过 epoll 监听到 “数据可读” 事件，从线程池分配线程执行`recv()`获取字节流。
2. 字节流传入协议模块，`decode()`方法解析出完整消息（处理粘包）。
3. 应用层模块调用用户注册的消息回调函数，传入消息内容与连接上下文。
4. 业务逻辑处理完成后，调用`send()`接口，框架自动通过协议模块`encode()`+ 网络 I/O 模块发送响应。

## 三。技术选型（MVP 阶段）

- **开发语言**：C++（兼顾性能与面向对象特性，适合模块化封装）。
- **I/O 复用**：epoll（Linux 环境下高性能选择，避免依赖 libevent 等第三方库，降低黑盒复杂度）。
- **线程库**：C++11 `std::thread`+`std::mutex`（MVP 阶段够用，后续可优化为无锁队列减少锁竞争）。
- **内存管理**：简单缓冲区池（预分配 1KB 小缓冲区，减少`malloc`调用开销）。

## 四. MVP 迭代规划（体现落地思路）

| 阶段 | 目标               | 核心功能                          | 验证方式                |
| ---- | ------------------ | --------------------------------- | ----------------------- |
| V0.1 | 跑通基础流程       | 单 Reactor + 单连接通信           | 客户端可连接并收发消息  |
| V0.2 | 支持多连接与线程池 | 多线程 I/O 池 + 连接池 + 粘包处理 | 1000 并发连接压测无崩溃 |
| V0.3 | 性能优化与黑盒封装 | 优化线程调度 + 极简接口封装       | QPS≥10w，延迟 < 1ms     |

### 说明

本次需求分析聚焦 MVP 阶段的 “可实现目标”，通过黑盒封装隐藏复杂细节（如 epoll、线程调度），同时明确各模块的职责与交互，既保证校招项目的完成度，又为面试时阐述 “扩展思路”（如多 Reactor、协议扩展）预留空间。
=======
A modular, high-performance network framework based on Reactor model (supporting 1M+ concurrent connections)
>>>>>>> e26495565593f3f3c26f6d70217ffd1e2ce71adf
