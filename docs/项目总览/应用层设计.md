# NetBoxé¡¹ç›®é¢è¯•æ€»ç»“ - ç¬¬ä¸‰éƒ¨åˆ†ï¼šåº”ç”¨å±‚è®¾è®¡ä¸ä¸šåŠ¡å®ç°

## ğŸ—ï¸ åº”ç”¨å±‚æ¶æ„è®¾è®¡

### åº”ç”¨å±‚åŸºç±»è®¾è®¡

```cpp
class ApplicationServer : public TcpServer {
public:
    ApplicationServer(const std::string& ip, int port, IOMultiplexer::IOType io_type, IThreadPool* pool = nullptr);
    virtual ~ApplicationServer();

protected:
    std::unique_ptr<ProtocolRouter> m_router;
    IThreadPool* m_pool;

    // åè®®è·¯ç”±å™¨åˆå§‹åŒ–ï¼ˆç”±å­ç±»å®ç°ï¼‰
    virtual void initializeProtocolRouter() = 0;

    // ä¸šåŠ¡ç›¸å…³æ¥å£ï¼ˆç”±å­ç±»å®ç°ï¼‰
    virtual std::string handleHttpRequest(const std::string& request, int clientFd) = 0;
    virtual std::string handleBusinessLogic(const std::string& command, const std::vector<std::string>& args) = 0;
    virtual bool parseRequestPath(const std::string& path, std::string& command, std::vector<std::string>& args) = 0;

    // ç”ŸæˆJSONå“åº”
    std::string generateJsonResponse(bool success, const std::string& data, const std::string& message);

    // ç½‘ç»œäº‹ä»¶å›è°ƒ
    virtual void onDataReceived(int clientFd, const char* data, size_t len) override;
    virtual void onClientConnected(int clientFd) override;
    virtual void onClientDisconnected(int clientFd) override;
};
```

### è®¾è®¡æ¨¡å¼åº”ç”¨

#### 1. æ¨¡æ¿æ–¹æ³•æ¨¡å¼
```cpp
// åŸºç±»å®šä¹‰ç®—æ³•éª¨æ¶
class ApplicationServer {
protected:
    virtual void initializeProtocolRouter() = 0;  // å­ç±»å®ç°
    virtual std::string handleBusinessLogic(...) = 0;  // å­ç±»å®ç°
    
public:
    bool start() {
        initializeProtocolRouter();  // è°ƒç”¨å­ç±»å®ç°
        return TcpServer::start();
    }
};
```

#### 2. ç­–ç•¥æ¨¡å¼
```cpp
// ä¸åŒçš„IOå¤šè·¯å¤ç”¨ç­–ç•¥
class IOMultiplexer {
public:
    virtual bool init() = 0;
    virtual bool addfd(int fd, EventType events) = 0;
    virtual int wait(std::vector<std::pair<int, EventType>>& activeEvents, int timeout) = 0;
};

class EpollMultiplexer : public IOMultiplexer { /* å®ç° */ };
class SelectMultiplexer : public IOMultiplexer { /* å®ç° */ };
class PollMultiplexer : public IOMultiplexer { /* å®ç° */ };
```

#### 3. è§‚å¯Ÿè€…æ¨¡å¼
```cpp
// å›è°ƒæœºåˆ¶
protocol->setPacketCallback([this](const std::vector<char>& packet) {
    this->onPacketReceived(packet);  // ä¸šåŠ¡å¤„ç†
});

protocol->setErrorCallback([](const std::string& error) {
    Logger::error("åè®®é”™è¯¯: " + error);  // é”™è¯¯å¤„ç†
});
```

## ğŸ¯ å…·ä½“ä¸šåŠ¡å®ç°

### 1. EchoServerå®ç°

#### æ ¸å¿ƒåŠŸèƒ½
```cpp
class EchoServer : public ApplicationServer {
public:
    EchoServer(const std::string& ip, int port, IOMultiplexer::IOType io_type, IThreadPool* pool = nullptr);
    ~EchoServer();

protected:
    void initializeProtocolRouter() override;
    std::string handleHttpRequest(const std::string& request, int clientFd) override;
    std::string handleBusinessLogic(const std::string& command, const std::vector<std::string>& args) override;
    bool parseRequestPath(const std::string& path, std::string& command, std::vector<std::string>& args) override;

private:
    void onPacketReceived(const std::vector<char>& packet);
    void onHttpPacketReceived(const std::vector<char>& packet);
    
    ProtocolRouter m_router;
    int m_currentClientFd = -1;
};
```

#### åè®®æ³¨å†Œ
```cpp
void EchoServer::initializeProtocolRouter() {
    // æ³¨å†ŒSimpleHeaderåè®®
    auto simpleProto = std::make_shared<SimpleHeaderProtocol>();
    simpleProto->setPacketCallback([this](const std::vector<char>& packet) {
        this->onPacketReceived(packet);
    });
    simpleProto->setFlowControl(1024, 1024);  // 1KB/s
    m_router.registerProtocol(1, simpleProto);

    // æ³¨å†ŒHTTPåè®®
    auto httpProto = std::make_shared<HttpProtocol>();
    httpProto->setPacketCallback([this](const std::vector<char>& packet) {
        this->onHttpPacketReceived(packet);
    });
    httpProto->setFlowControl(1024*1024, 1024*1024);  // 1MB/s
    m_router.registerProtocol(2, httpProto);
}
```

#### ä¸šåŠ¡å¤„ç†
```cpp
void EchoServer::onPacketReceived(const std::vector<char>& packet) {
    // è§£æä¸šåŠ¡æ•°æ®
    std::string message(packet.begin(), packet.end());
    
    // æ„é€ å›æ˜¾æ¶ˆæ¯
    std::string echoMessage = "Echo: " + message;
    
    // ä½¿ç”¨åè®®å±‚å°åŒ…
    auto simpleProto = std::make_shared<SimpleHeaderProtocol>();
    std::vector<char> response;
    simpleProto->pack(echoMessage.data(), echoMessage.size(), response);
    
    // å‘é€å›å®¢æˆ·ç«¯
    if (m_currentClientFd > 0) {
        send(m_currentClientFd, response.data(), response.size(), 0);
    }
}
```

### 2. æ–‡ä»¶ä¼ è¾“æœåŠ¡è®¾è®¡ï¼ˆæ¨èå®ç°ï¼‰

#### æœåŠ¡ç±»è®¾è®¡
```cpp
class FileTransferServer : public ApplicationServer {
public:
    FileTransferServer(const std::string& ip, int port, IOMultiplexer::IOType io_type, IThreadPool* pool = nullptr);
    ~FileTransferServer();

protected:
    void initializeProtocolRouter() override;
    std::string handleHttpRequest(const std::string& request, int clientFd) override;
    std::string handleBusinessLogic(const std::string& command, const std::vector<std::string>& args) override;
    bool parseRequestPath(const std::string& path, std::string& command, std::vector<std::string>& args) override;

private:
    void onFileUploadRequest(const std::vector<char>& packet);
    void onFileDownloadRequest(const std::vector<char>& packet);
    void onFileListRequest(const std::vector<char>& packet);
    void onFileDeleteRequest(const std::vector<char>& packet);
    
    FileTransferService m_fileService;
    std::string m_uploadDir;
    std::string m_downloadDir;
};
```

#### æ–‡ä»¶ä¼ è¾“æœåŠ¡
```cpp
class FileTransferService {
public:
    // æ–‡ä»¶ä¸Šä¼ 
    std::string handleUpload(const std::string& filename, const std::vector<char>& data);
    
    // æ–‡ä»¶ä¸‹è½½
    std::vector<char> handleDownload(const std::string& filename);
    
    // æ–‡ä»¶åˆ—è¡¨
    std::string handleList();
    
    // æ–‡ä»¶åˆ é™¤
    bool handleDelete(const std::string& filename);
    
    // æ–­ç‚¹ç»­ä¼ 
    std::vector<char> handleResumeDownload(const std::string& filename, size_t offset);
    
    // æ–‡ä»¶æ ¡éªŒ
    std::string calculateMD5(const std::string& filename);
    
private:
    std::string m_baseDir;
    std::mutex m_fileMutex;
    std::unordered_map<std::string, FileInfo> m_fileInfo;
};
```

#### æ–‡ä»¶ä¿¡æ¯ç»“æ„
```cpp
struct FileInfo {
    std::string filename;
    size_t size;
    std::string md5;
    std::chrono::system_clock::time_point createTime;
    std::chrono::system_clock::time_point modifyTime;
    bool isDirectory;
};
```

### 3. èŠå¤©ç³»ç»Ÿè®¾è®¡

#### èŠå¤©æœåŠ¡å™¨
```cpp
class ChatServer : public ApplicationServer {
public:
    ChatServer(const std::string& ip, int port, IOMultiplexer::IOType io_type, IThreadPool* pool = nullptr);
    ~ChatServer();

protected:
    void initializeProtocolRouter() override;
    std::string handleHttpRequest(const std::string& request, int clientFd) override;
    std::string handleBusinessLogic(const std::string& command, const std::vector<std::string>& args) override;
    bool parseRequestPath(const std::string& path, std::string& command, std::vector<std::string>& args) override;

private:
    void onUserLogin(const std::vector<char>& packet);
    void onMessageBroadcast(const std::vector<char>& packet);
    void onPrivateMessage(const std::vector<char>& packet);
    void onUserLogout(const std::vector<char>& packet);
    
    ChatService m_chatService;
    std::unordered_map<int, UserInfo> m_onlineUsers;
    std::mutex m_usersMutex;
};
```

#### èŠå¤©æœåŠ¡
```cpp
class ChatService {
public:
    // ç”¨æˆ·ç®¡ç†
    bool userLogin(const std::string& username, const std::string& password);
    void userLogout(const std::string& username);
    std::vector<std::string> getOnlineUsers();
    
    // æ¶ˆæ¯å¤„ç†
    void broadcastMessage(const std::string& from, const std::string& message);
    void sendPrivateMessage(const std::string& from, const std::string& to, const std::string& message);
    
    // å†å²æ¶ˆæ¯
    std::vector<Message> getHistoryMessages(size_t limit = 100);
    void saveMessage(const Message& message);
    
private:
    std::unordered_map<std::string, UserInfo> m_users;
    std::vector<Message> m_messageHistory;
    std::mutex m_dataMutex;
};
```

## ğŸ”§ ä¸šåŠ¡å±‚æŠ€æœ¯è¦ç‚¹

### 1. æ•°æ®åºåˆ—åŒ–

#### JSONåºåˆ—åŒ–
```cpp
std::string generateJsonResponse(bool success, const std::string& data, const std::string& message) {
    nlohmann::json response;
    response["success"] = success;
    response["data"] = data;
    response["message"] = message;
    response["timestamp"] = std::time(nullptr);
    return response.dump();
}
```

#### äºŒè¿›åˆ¶åºåˆ—åŒ–
```cpp
struct FileTransferPacket {
    uint32_t command;      // å‘½ä»¤ç±»å‹
    uint32_t filenameLen;  // æ–‡ä»¶åé•¿åº¦
    uint32_t dataLen;      // æ•°æ®é•¿åº¦
    char filename[256];    // æ–‡ä»¶å
    char data[];          // æ•°æ®å†…å®¹
};
```

### 2. é”™è¯¯å¤„ç†æœºåˆ¶

#### å¼‚å¸¸å¤„ç†
```cpp
class FileTransferException : public std::exception {
public:
    FileTransferException(const std::string& message) : m_message(message) {}
    const char* what() const noexcept override { return m_message.c_str(); }
    
private:
    std::string m_message;
};

// ä½¿ç”¨ç¤ºä¾‹
try {
    auto data = m_fileService.handleDownload(filename);
    return generateJsonResponse(true, base64_encode(data), "ä¸‹è½½æˆåŠŸ");
} catch (const FileTransferException& e) {
    return generateJsonResponse(false, "", e.what());
} catch (const std::exception& e) {
    return generateJsonResponse(false, "", "ç³»ç»Ÿé”™è¯¯: " + std::string(e.what()));
}
```

### 3. å®‰å…¨æœºåˆ¶

#### æ–‡ä»¶è·¯å¾„å®‰å…¨æ£€æŸ¥
```cpp
bool isPathSafe(const std::string& path) {
    // æ£€æŸ¥è·¯å¾„éå†æ”»å‡»
    if (path.find("..") != std::string::npos) {
        return false;
    }
    
    // æ£€æŸ¥ç»å¯¹è·¯å¾„
    if (path[0] == '/') {
        return false;
    }
    
    // æ£€æŸ¥ç‰¹æ®Šå­—ç¬¦
    if (path.find("\\") != std::string::npos) {
        return false;
    }
    
    return true;
}
```

#### æ–‡ä»¶å¤§å°é™åˆ¶
```cpp
bool checkFileSize(size_t size) {
    const size_t MAX_FILE_SIZE = 100 * 1024 * 1024;  // 100MB
    return size <= MAX_FILE_SIZE;
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ç®¡ç†

#### å¯¹è±¡æ± 
```cpp
template<typename T>
class ObjectPool {
public:
    std::shared_ptr<T> acquire() {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (m_pool.empty()) {
            return std::make_shared<T>();
        }
        auto obj = m_pool.back();
        m_pool.pop_back();
        return obj;
    }
    
    void release(std::shared_ptr<T> obj) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_pool.push_back(obj);
    }
    
private:
    std::vector<std::shared_ptr<T>> m_pool;
    std::mutex m_mutex;
};
```

#### é›¶æ‹·è´ä¼˜åŒ–
```cpp
// ä½¿ç”¨sendfileè¿›è¡Œé›¶æ‹·è´æ–‡ä»¶ä¼ è¾“
ssize_t sendFile(int out_fd, int in_fd, off_t* offset, size_t count) {
    return sendfile(out_fd, in_fd, offset, count);
}
```

### 2. å¹¶å‘æ§åˆ¶

#### è¿æ¥é™åˆ¶
```cpp
class ConnectionLimiter {
public:
    bool canAccept() {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_currentConnections < m_maxConnections;
    }
    
    void increment() {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_currentConnections++;
    }
    
    void decrement() {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_currentConnections--;
    }
    
private:
    std::atomic<size_t> m_currentConnections{0};
    const size_t m_maxConnections = 10000;
    std::mutex m_mutex;
};
```

## ğŸ¯ é¢è¯•é—®é¢˜è¯¦è§£

### Q1: å¦‚ä½•è®¾è®¡ä¸€ä¸ªé«˜å¹¶å‘çš„æ–‡ä»¶ä¼ è¾“æœåŠ¡ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
```
1. **æ¶æ„è®¾è®¡**ï¼š
   - ä½¿ç”¨å¼‚æ­¥IO + çº¿ç¨‹æ± 
   - åˆ†ç‰‡ä¼ è¾“å¤§æ–‡ä»¶
   - æ–­ç‚¹ç»­ä¼ æ”¯æŒ

2. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - é›¶æ‹·è´æŠ€æœ¯ï¼ˆsendfileï¼‰
   - å†…å­˜æ˜ å°„ï¼ˆmmapï¼‰
   - å¯¹è±¡æ± å¤ç”¨

3. **å®‰å…¨è€ƒè™‘**ï¼š
   - è·¯å¾„å®‰å…¨æ£€æŸ¥
   - æ–‡ä»¶å¤§å°é™åˆ¶
   - æ–‡ä»¶ç±»å‹éªŒè¯

4. **å¯é æ€§**ï¼š
   - MD5æ ¡éªŒ
   - é‡ä¼ æœºåˆ¶
   - é”™è¯¯æ¢å¤
```

### Q2: å¦‚ä½•å®ç°ä¸€ä¸ªå®æ—¶èŠå¤©ç³»ç»Ÿï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
```
1. **æ¶ˆæ¯ä¼ é€’**ï¼š
   - ä½¿ç”¨WebSocketæˆ–è‡ªå®šä¹‰åè®®
   - æ¶ˆæ¯é˜Ÿåˆ—ç¼“å†²
   - å¹¿æ’­æœºåˆ¶

2. **ç”¨æˆ·ç®¡ç†**ï¼š
   - åœ¨çº¿çŠ¶æ€ç»´æŠ¤
   - ç”¨æˆ·è®¤è¯
   - ä¼šè¯ç®¡ç†

3. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - æ¶ˆæ¯åˆ†ç‰‡
   - ç¦»çº¿æ¶ˆæ¯å­˜å‚¨
   - æ¶ˆæ¯å»é‡

4. **æ‰©å±•æ€§**ï¼š
   - é›†ç¾¤éƒ¨ç½²
   - æ¶ˆæ¯è·¯ç”±
   - è´Ÿè½½å‡è¡¡
```

### Q3: å¦‚ä½•ä¿è¯ä¸šåŠ¡å±‚çš„å¯æ‰©å±•æ€§ï¼Ÿ

**æ ‡å‡†ç­”æ¡ˆï¼š**
```
1. **æ¥å£è®¾è®¡**ï¼š
   - ç»Ÿä¸€çš„ä¸šåŠ¡æ¥å£
   - æ’ä»¶åŒ–æ¶æ„
   - é…ç½®åŒ–å‚æ•°

2. **æ¨¡å—åŒ–**ï¼š
   - ä¸šåŠ¡æ¨¡å—ç‹¬ç«‹
   - ä¾èµ–æ³¨å…¥
   - æ¾è€¦åˆè®¾è®¡

3. **åè®®æ‰©å±•**ï¼š
   - åè®®ç‰ˆæœ¬ç®¡ç†
   - å‘åå…¼å®¹
   - åè®®å‡çº§æœºåˆ¶

4. **éƒ¨ç½²æ‰©å±•**ï¼š
   - å¾®æœåŠ¡æ¶æ„
   - å®¹å™¨åŒ–éƒ¨ç½²
   - æœåŠ¡å‘ç°
```

## ğŸ“ˆ ä¸šåŠ¡æŒ‡æ ‡

### æ–‡ä»¶ä¼ è¾“æœåŠ¡æŒ‡æ ‡
- **ä¼ è¾“é€Ÿåº¦**ï¼š100MB/s
- **å¹¶å‘ä¼ è¾“**ï¼š1000+
- **æ–­ç‚¹ç»­ä¼ **ï¼šæ”¯æŒ
- **æ–‡ä»¶å¤§å°**ï¼šæœ€å¤§10GB

### èŠå¤©ç³»ç»ŸæŒ‡æ ‡
- **åœ¨çº¿ç”¨æˆ·**ï¼š10000+
- **æ¶ˆæ¯å»¶è¿Ÿ**ï¼š< 100ms
- **æ¶ˆæ¯åå**ï¼š10000 msg/s
- **å†å²æ¶ˆæ¯**ï¼šæ”¯æŒ

---

**æ€»ç»“ï¼šåº”ç”¨å±‚è®¾è®¡ä½“ç°äº†ä¸šåŠ¡ç†è§£èƒ½åŠ›å’Œå·¥ç¨‹å®è·µèƒ½åŠ›** 