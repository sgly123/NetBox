# NetBox项目面试总结 - 第三部分：应用层设计与业务实现

## 🏗️ 应用层架构设计

### 应用层基类设计

```cpp
class ApplicationServer : public TcpServer {
public:
    ApplicationServer(const std::string& ip, int port, IOMultiplexer::IOType io_type, IThreadPool* pool = nullptr);
    virtual ~ApplicationServer();

protected:
    std::unique_ptr<ProtocolRouter> m_router;
    IThreadPool* m_pool;

    // 协议路由器初始化（由子类实现）
    virtual void initializeProtocolRouter() = 0;

    // 业务相关接口（由子类实现）
    virtual std::string handleHttpRequest(const std::string& request, int clientFd) = 0;
    virtual std::string handleBusinessLogic(const std::string& command, const std::vector<std::string>& args) = 0;
    virtual bool parseRequestPath(const std::string& path, std::string& command, std::vector<std::string>& args) = 0;

    // 生成JSON响应
    std::string generateJsonResponse(bool success, const std::string& data, const std::string& message);

    // 网络事件回调
    virtual void onDataReceived(int clientFd, const char* data, size_t len) override;
    virtual void onClientConnected(int clientFd) override;
    virtual void onClientDisconnected(int clientFd) override;
};
```

### 设计模式应用

#### 1. 模板方法模式
```cpp
// 基类定义算法骨架
class ApplicationServer {
protected:
    virtual void initializeProtocolRouter() = 0;  // 子类实现
    virtual std::string handleBusinessLogic(...) = 0;  // 子类实现
    
public:
    bool start() {
        initializeProtocolRouter();  // 调用子类实现
        return TcpServer::start();
    }
};
```

#### 2. 策略模式
```cpp
// 不同的IO多路复用策略
class IOMultiplexer {
public:
    virtual bool init() = 0;
    virtual bool addfd(int fd, EventType events) = 0;
    virtual int wait(std::vector<std::pair<int, EventType>>& activeEvents, int timeout) = 0;
};

class EpollMultiplexer : public IOMultiplexer { /* 实现 */ };
class SelectMultiplexer : public IOMultiplexer { /* 实现 */ };
class PollMultiplexer : public IOMultiplexer { /* 实现 */ };
```

#### 3. 观察者模式
```cpp
// 回调机制
protocol->setPacketCallback([this](const std::vector<char>& packet) {
    this->onPacketReceived(packet);  // 业务处理
});

protocol->setErrorCallback([](const std::string& error) {
    Logger::error("协议错误: " + error);  // 错误处理
});
```

## 🎯 具体业务实现

### 1. EchoServer实现

#### 核心功能
```cpp
class EchoServer : public ApplicationServer {
public:
    EchoServer(const std::string& ip, int port, IOMultiplexer::IOType io_type, IThreadPool* pool = nullptr);
    ~EchoServer();

protected:
    void initializeProtocolRouter() override;
    std::string handleHttpRequest(const std::string& request, int clientFd) override;
    std::string handleBusinessLogic(const std::string& command, const std::vector<std::string>& args) override;
    bool parseRequestPath(const std::string& path, std::string& command, std::vector<std::string>& args) override;

private:
    void onPacketReceived(const std::vector<char>& packet);
    void onHttpPacketReceived(const std::vector<char>& packet);
    
    ProtocolRouter m_router;
    int m_currentClientFd = -1;
};
```

#### 协议注册
```cpp
void EchoServer::initializeProtocolRouter() {
    // 注册SimpleHeader协议
    auto simpleProto = std::make_shared<SimpleHeaderProtocol>();
    simpleProto->setPacketCallback([this](const std::vector<char>& packet) {
        this->onPacketReceived(packet);
    });
    simpleProto->setFlowControl(1024, 1024);  // 1KB/s
    m_router.registerProtocol(1, simpleProto);

    // 注册HTTP协议
    auto httpProto = std::make_shared<HttpProtocol>();
    httpProto->setPacketCallback([this](const std::vector<char>& packet) {
        this->onHttpPacketReceived(packet);
    });
    httpProto->setFlowControl(1024*1024, 1024*1024);  // 1MB/s
    m_router.registerProtocol(2, httpProto);
}
```

#### 业务处理
```cpp
void EchoServer::onPacketReceived(const std::vector<char>& packet) {
    // 解析业务数据
    std::string message(packet.begin(), packet.end());
    
    // 构造回显消息
    std::string echoMessage = "Echo: " + message;
    
    // 使用协议层封包
    auto simpleProto = std::make_shared<SimpleHeaderProtocol>();
    std::vector<char> response;
    simpleProto->pack(echoMessage.data(), echoMessage.size(), response);
    
    // 发送回客户端
    if (m_currentClientFd > 0) {
        send(m_currentClientFd, response.data(), response.size(), 0);
    }
}
```

### 2. 文件传输服务设计（推荐实现）

#### 服务类设计
```cpp
class FileTransferServer : public ApplicationServer {
public:
    FileTransferServer(const std::string& ip, int port, IOMultiplexer::IOType io_type, IThreadPool* pool = nullptr);
    ~FileTransferServer();

protected:
    void initializeProtocolRouter() override;
    std::string handleHttpRequest(const std::string& request, int clientFd) override;
    std::string handleBusinessLogic(const std::string& command, const std::vector<std::string>& args) override;
    bool parseRequestPath(const std::string& path, std::string& command, std::vector<std::string>& args) override;

private:
    void onFileUploadRequest(const std::vector<char>& packet);
    void onFileDownloadRequest(const std::vector<char>& packet);
    void onFileListRequest(const std::vector<char>& packet);
    void onFileDeleteRequest(const std::vector<char>& packet);
    
    FileTransferService m_fileService;
    std::string m_uploadDir;
    std::string m_downloadDir;
};
```

#### 文件传输服务
```cpp
class FileTransferService {
public:
    // 文件上传
    std::string handleUpload(const std::string& filename, const std::vector<char>& data);
    
    // 文件下载
    std::vector<char> handleDownload(const std::string& filename);
    
    // 文件列表
    std::string handleList();
    
    // 文件删除
    bool handleDelete(const std::string& filename);
    
    // 断点续传
    std::vector<char> handleResumeDownload(const std::string& filename, size_t offset);
    
    // 文件校验
    std::string calculateMD5(const std::string& filename);
    
private:
    std::string m_baseDir;
    std::mutex m_fileMutex;
    std::unordered_map<std::string, FileInfo> m_fileInfo;
};
```

#### 文件信息结构
```cpp
struct FileInfo {
    std::string filename;
    size_t size;
    std::string md5;
    std::chrono::system_clock::time_point createTime;
    std::chrono::system_clock::time_point modifyTime;
    bool isDirectory;
};
```

### 3. 聊天系统设计

#### 聊天服务器
```cpp
class ChatServer : public ApplicationServer {
public:
    ChatServer(const std::string& ip, int port, IOMultiplexer::IOType io_type, IThreadPool* pool = nullptr);
    ~ChatServer();

protected:
    void initializeProtocolRouter() override;
    std::string handleHttpRequest(const std::string& request, int clientFd) override;
    std::string handleBusinessLogic(const std::string& command, const std::vector<std::string>& args) override;
    bool parseRequestPath(const std::string& path, std::string& command, std::vector<std::string>& args) override;

private:
    void onUserLogin(const std::vector<char>& packet);
    void onMessageBroadcast(const std::vector<char>& packet);
    void onPrivateMessage(const std::vector<char>& packet);
    void onUserLogout(const std::vector<char>& packet);
    
    ChatService m_chatService;
    std::unordered_map<int, UserInfo> m_onlineUsers;
    std::mutex m_usersMutex;
};
```

#### 聊天服务
```cpp
class ChatService {
public:
    // 用户管理
    bool userLogin(const std::string& username, const std::string& password);
    void userLogout(const std::string& username);
    std::vector<std::string> getOnlineUsers();
    
    // 消息处理
    void broadcastMessage(const std::string& from, const std::string& message);
    void sendPrivateMessage(const std::string& from, const std::string& to, const std::string& message);
    
    // 历史消息
    std::vector<Message> getHistoryMessages(size_t limit = 100);
    void saveMessage(const Message& message);
    
private:
    std::unordered_map<std::string, UserInfo> m_users;
    std::vector<Message> m_messageHistory;
    std::mutex m_dataMutex;
};
```

## 🔧 业务层技术要点

### 1. 数据序列化

#### JSON序列化
```cpp
std::string generateJsonResponse(bool success, const std::string& data, const std::string& message) {
    nlohmann::json response;
    response["success"] = success;
    response["data"] = data;
    response["message"] = message;
    response["timestamp"] = std::time(nullptr);
    return response.dump();
}
```

#### 二进制序列化
```cpp
struct FileTransferPacket {
    uint32_t command;      // 命令类型
    uint32_t filenameLen;  // 文件名长度
    uint32_t dataLen;      // 数据长度
    char filename[256];    // 文件名
    char data[];          // 数据内容
};
```

### 2. 错误处理机制

#### 异常处理
```cpp
class FileTransferException : public std::exception {
public:
    FileTransferException(const std::string& message) : m_message(message) {}
    const char* what() const noexcept override { return m_message.c_str(); }
    
private:
    std::string m_message;
};

// 使用示例
try {
    auto data = m_fileService.handleDownload(filename);
    return generateJsonResponse(true, base64_encode(data), "下载成功");
} catch (const FileTransferException& e) {
    return generateJsonResponse(false, "", e.what());
} catch (const std::exception& e) {
    return generateJsonResponse(false, "", "系统错误: " + std::string(e.what()));
}
```

### 3. 安全机制

#### 文件路径安全检查
```cpp
bool isPathSafe(const std::string& path) {
    // 检查路径遍历攻击
    if (path.find("..") != std::string::npos) {
        return false;
    }
    
    // 检查绝对路径
    if (path[0] == '/') {
        return false;
    }
    
    // 检查特殊字符
    if (path.find("\\") != std::string::npos) {
        return false;
    }
    
    return true;
}
```

#### 文件大小限制
```cpp
bool checkFileSize(size_t size) {
    const size_t MAX_FILE_SIZE = 100 * 1024 * 1024;  // 100MB
    return size <= MAX_FILE_SIZE;
}
```

## 📊 性能优化策略

### 1. 内存管理

#### 对象池
```cpp
template<typename T>
class ObjectPool {
public:
    std::shared_ptr<T> acquire() {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (m_pool.empty()) {
            return std::make_shared<T>();
        }
        auto obj = m_pool.back();
        m_pool.pop_back();
        return obj;
    }
    
    void release(std::shared_ptr<T> obj) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_pool.push_back(obj);
    }
    
private:
    std::vector<std::shared_ptr<T>> m_pool;
    std::mutex m_mutex;
};
```

#### 零拷贝优化
```cpp
// 使用sendfile进行零拷贝文件传输
ssize_t sendFile(int out_fd, int in_fd, off_t* offset, size_t count) {
    return sendfile(out_fd, in_fd, offset, count);
}
```

### 2. 并发控制

#### 连接限制
```cpp
class ConnectionLimiter {
public:
    bool canAccept() {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_currentConnections < m_maxConnections;
    }
    
    void increment() {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_currentConnections++;
    }
    
    void decrement() {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_currentConnections--;
    }
    
private:
    std::atomic<size_t> m_currentConnections{0};
    const size_t m_maxConnections = 10000;
    std::mutex m_mutex;
};
```

## 🎯 面试问题详解

### Q1: 如何设计一个高并发的文件传输服务？

**标准答案：**
```
1. **架构设计**：
   - 使用异步IO + 线程池
   - 分片传输大文件
   - 断点续传支持

2. **性能优化**：
   - 零拷贝技术（sendfile）
   - 内存映射（mmap）
   - 对象池复用

3. **安全考虑**：
   - 路径安全检查
   - 文件大小限制
   - 文件类型验证

4. **可靠性**：
   - MD5校验
   - 重传机制
   - 错误恢复
```

### Q2: 如何实现一个实时聊天系统？

**标准答案：**
```
1. **消息传递**：
   - 使用WebSocket或自定义协议
   - 消息队列缓冲
   - 广播机制

2. **用户管理**：
   - 在线状态维护
   - 用户认证
   - 会话管理

3. **性能优化**：
   - 消息分片
   - 离线消息存储
   - 消息去重

4. **扩展性**：
   - 集群部署
   - 消息路由
   - 负载均衡
```

### Q3: 如何保证业务层的可扩展性？

**标准答案：**
```
1. **接口设计**：
   - 统一的业务接口
   - 插件化架构
   - 配置化参数

2. **模块化**：
   - 业务模块独立
   - 依赖注入
   - 松耦合设计

3. **协议扩展**：
   - 协议版本管理
   - 向后兼容
   - 协议升级机制

4. **部署扩展**：
   - 微服务架构
   - 容器化部署
   - 服务发现
```

## 📈 业务指标

### 文件传输服务指标
- **传输速度**：100MB/s
- **并发传输**：1000+
- **断点续传**：支持
- **文件大小**：最大10GB

### 聊天系统指标
- **在线用户**：10000+
- **消息延迟**：< 100ms
- **消息吞吐**：10000 msg/s
- **历史消息**：支持

---

**总结：应用层设计体现了业务理解能力和工程实践能力** 