# NetBox 协议扩展指南

## 🎯 **扩展目标**

本指南展示如何在NetBox项目中扩展新的协议支持，以HTTP协议为例，说明协议扩展的完整流程。

## 📋 **协议扩展步骤**

### **1. 继承ProtocolBase基类**

所有协议都必须继承`ProtocolBase`基类，实现以下核心接口：

```cpp
class YourProtocol : public ProtocolBase {
public:
    // 必须实现的接口
    size_t onDataReceived(const char* data, size_t len) override;
    bool pack(const char* data, size_t len, std::vector<char>& out) override;
    std::string getType() const override;
    uint32_t getProtocolId() const override;
    void reset() override;
};
```

### **2. 定义协议特性**

根据协议特点，定义相应的枚举和结构：

```cpp
// HTTP协议示例
enum class Method {
    GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH, UNKNOWN
};

enum class StatusCode {
    OK = 200, CREATED = 201, BAD_REQUEST = 400, 
    NOT_FOUND = 404, INTERNAL_ERROR = 500
};

enum class Version {
    HTTP_1_0, HTTP_1_1, HTTP_2_0, UNKNOWN
};
```

### **3. 实现核心功能**

#### **A. 数据接收处理（拆包）**
```cpp
size_t YourProtocol::onDataReceived(const char* data, size_t len) {
    // 1. 流量控制检查
    if (!checkFlowControl(len)) {
        return 0;
    }
    
    // 2. 追加数据到缓冲区
    buffer_.append(reinterpret_cast<const uint8_t*>(data), len);
    
    // 3. 解析协议数据
    while (/* 有完整消息 */) {
        // 解析消息
        // 调用回调函数
        // 清理已处理数据
    }
    
    return processedBytes;
}
```

#### **B. 数据封包处理**
```cpp
bool YourProtocol::pack(const char* data, size_t len, std::vector<char>& out) {
    // 1. 流量控制检查
    if (!checkFlowControl(len)) {
        return false;
    }
    
    // 2. 构建协议格式
    std::string protocolData = buildProtocolFormat(data, len);
    
    // 3. 输出到缓冲区
    out.assign(protocolData.begin(), protocolData.end());
    return true;
}
```

### **4. 协议特定功能**

根据协议特点，添加特定的功能方法：

```cpp
// HTTP协议特有方法
bool packRequest(Method method, const std::string& path, 
                const std::map<std::string, std::string>& headers,
                const std::string& body, std::vector<char>& out);

bool packResponse(StatusCode statusCode, 
                const std::map<std::string, std::string>& headers,
                const std::string& body, std::vector<char>& out);
```

## 🔧 **HTTP协议实现示例**

### **协议特点分析**

HTTP协议具有以下特点：
- **文本协议**：基于ASCII文本，易于调试
- **请求-响应模式**：客户端请求，服务器响应
- **无状态**：每个请求独立处理
- **可扩展**：支持自定义头部和扩展

### **核心实现要点**

#### **1. 消息解析**
```cpp
// 解析HTTP头部
bool parseHeaders(const std::vector<std::string>& headerLines, 
                 std::map<std::string, std::string>& headers);

// 解析请求行
bool parseRequestLine(const std::string& line, HttpRequest& request);

// 解析响应行
bool parseResponseLine(const std::string& line, HttpResponse& response);
```

#### **2. 状态管理**
```cpp
bool parsingHeaders_ = true;      // 是否正在解析头部
bool parsingBody_ = false;        // 是否正在解析体
bool messageComplete_ = false;    // 消息是否完整
size_t expectedBodyLength_ = 0;   // 期望的体长度
```

#### **3. 错误处理**
```cpp
// 检查请求大小
if (buffer_.size() > maxRequestSize_) {
    if (errorCallback_) {
        errorCallback_("HTTP: Request too large");
    }
    reset();
    return 0;
}
```

## 📊 **协议扩展对比**

| 协议类型 | 特点 | 实现复杂度 | 使用场景 |
|---------|------|-----------|----------|
| SimpleHeader | 二进制，固定包头 | 简单 | 高性能通信 |
| HTTP | 文本，请求-响应 | 中等 | Web服务 |
| WebSocket | 二进制，双向通信 | 复杂 | 实时通信 |
| MQTT | 二进制，发布-订阅 | 复杂 | IoT设备 |

## 🚀 **扩展其他协议**

### **WebSocket协议扩展**

```cpp
class WebSocketProtocol : public ProtocolBase {
public:
    static constexpr uint32_t ID = 3;
    
    enum class Opcode {
        CONTINUATION = 0x0,
        TEXT = 0x1,
        BINARY = 0x2,
        CLOSE = 0x8,
        PING = 0x9,
        PONG = 0xA
    };
    
    // WebSocket握手
    bool handleHandshake(const std::string& request);
    
    // 封包WebSocket消息
    bool packMessage(Opcode opcode, const std::string& payload, 
                   std::vector<char>& out);
};
```

### **MQTT协议扩展**

```cpp
class MqttProtocol : public ProtocolBase {
public:
    static constexpr uint32_t ID = 4;
    
    enum class PacketType {
        CONNECT = 1,
        CONNACK = 2,
        PUBLISH = 3,
        PUBACK = 4,
        SUBSCRIBE = 8,
        SUBACK = 9,
        PINGREQ = 12,
        PINGRESP = 13,
        DISCONNECT = 14
    };
    
    // MQTT连接
    bool packConnect(const std::string& clientId, 
                    const std::string& username,
                    const std::string& password,
                    std::vector<char>& out);
    
    // MQTT发布
    bool packPublish(const std::string& topic, 
                    const std::string& payload,
                    uint16_t packetId,
                    std::vector<char>& out);
};
```

## 🧪 **测试策略**

### **1. 单元测试**
```cpp
// 测试协议解析
TEST(HttpProtocolTest, ParseGetRequest) {
    HttpProtocol protocol;
    std::string request = "GET /api/test HTTP/1.1\r\n\r\n";
    
    size_t processed = protocol.onDataReceived(request.c_str(), request.length());
    EXPECT_EQ(processed, request.length());
    EXPECT_TRUE(protocol.isComplete());
}
```

### **2. 集成测试**
```cpp
// 测试完整流程
TEST(HttpProtocolTest, CompleteFlow) {
    HttpProtocol protocol;
    
    // 设置回调
    protocol.setPacketCallback([](const std::vector<char>& packet) {
        // 验证解析结果
    });
    
    // 发送测试数据
    std::string testData = "HTTP/1.1 200 OK\r\n\r\n";
    protocol.onDataReceived(testData.c_str(), testData.length());
}
```

### **3. 性能测试**
```cpp
// 测试吞吐量
TEST(HttpProtocolTest, Throughput) {
    HttpProtocol protocol;
    
    // 发送大量请求
    for (int i = 0; i < 10000; ++i) {
        std::string request = "GET /api/test HTTP/1.1\r\n\r\n";
        protocol.onDataReceived(request.c_str(), request.length());
    }
    
    // 验证性能指标
}
```

## 📈 **性能优化建议**

### **1. 内存优化**
- 使用内存池管理缓冲区
- 避免频繁的内存分配
- 预分配足够的内存空间

### **2. 解析优化**
- 使用状态机进行解析
- 批量处理数据
- 减少字符串拷贝

### **3. 并发优化**
- 使用无锁数据结构
- 减少锁竞争
- 优化线程亲和性

## 🔄 **集成到框架**

### **1. 更新协议工厂**
```cpp
// 在ProtocolFactory中添加新协议
std::unique_ptr<ProtocolBase> createProtocol(uint32_t protocolId) {
    switch (protocolId) {
        case 1: return std::make_unique<SimpleHeaderProtocol>();
        case 2: return std::make_unique<HttpProtocol>();
        case 3: return std::make_unique<WebSocketProtocol>();
        case 4: return std::make_unique<MqttProtocol>();
        default: return nullptr;
    }
}
```

### **2. 更新服务器配置**
```cpp
// 在配置文件中添加协议支持
[protocols]
simple_header = 1
http = 2
websocket = 3
mqtt = 4
```

### **3. 添加路由支持**
```cpp
// 根据协议类型路由到不同的处理器
void handleConnection(Connection* conn) {
    switch (conn->getProtocolId()) {
        case 1: handleSimpleHeader(conn); break;
        case 2: handleHttp(conn); break;
        case 3: handleWebSocket(conn); break;
        case 4: handleMqtt(conn); break;
    }
}
```

## 📝 **总结**

协议扩展的关键要点：

1. **继承基类**：所有协议都必须继承`ProtocolBase`
2. **实现接口**：必须实现拆包、封包、类型识别等核心接口
3. **状态管理**：正确管理协议解析状态
4. **错误处理**：完善的错误检测和处理机制
5. **性能优化**：使用内存池、减少拷贝、优化解析
6. **测试验证**：全面的单元测试和集成测试
7. **框架集成**：更新工厂、配置、路由等框架组件

通过这种方式，可以轻松地在NetBox项目中扩展各种协议支持，满足不同的应用需求。 