# NetBox åè®®æ‰©å±•æŒ‡å—

## ğŸ¯ **æ‰©å±•ç›®æ ‡**

æœ¬æŒ‡å—å±•ç¤ºå¦‚ä½•åœ¨NetBoxé¡¹ç›®ä¸­æ‰©å±•æ–°çš„åè®®æ”¯æŒï¼Œä»¥HTTPåè®®ä¸ºä¾‹ï¼Œè¯´æ˜åè®®æ‰©å±•çš„å®Œæ•´æµç¨‹ã€‚

## ğŸ“‹ **åè®®æ‰©å±•æ­¥éª¤**

### **1. ç»§æ‰¿ProtocolBaseåŸºç±»**

æ‰€æœ‰åè®®éƒ½å¿…é¡»ç»§æ‰¿`ProtocolBase`åŸºç±»ï¼Œå®ç°ä»¥ä¸‹æ ¸å¿ƒæ¥å£ï¼š

```cpp
class YourProtocol : public ProtocolBase {
public:
    // å¿…é¡»å®ç°çš„æ¥å£
    size_t onDataReceived(const char* data, size_t len) override;
    bool pack(const char* data, size_t len, std::vector<char>& out) override;
    std::string getType() const override;
    uint32_t getProtocolId() const override;
    void reset() override;
};
```

### **2. å®šä¹‰åè®®ç‰¹æ€§**

æ ¹æ®åè®®ç‰¹ç‚¹ï¼Œå®šä¹‰ç›¸åº”çš„æšä¸¾å’Œç»“æ„ï¼š

```cpp
// HTTPåè®®ç¤ºä¾‹
enum class Method {
    GET, POST, PUT, DELETE, HEAD, OPTIONS, PATCH, UNKNOWN
};

enum class StatusCode {
    OK = 200, CREATED = 201, BAD_REQUEST = 400, 
    NOT_FOUND = 404, INTERNAL_ERROR = 500
};

enum class Version {
    HTTP_1_0, HTTP_1_1, HTTP_2_0, UNKNOWN
};
```

### **3. å®ç°æ ¸å¿ƒåŠŸèƒ½**

#### **A. æ•°æ®æ¥æ”¶å¤„ç†ï¼ˆæ‹†åŒ…ï¼‰**
```cpp
size_t YourProtocol::onDataReceived(const char* data, size_t len) {
    // 1. æµé‡æ§åˆ¶æ£€æŸ¥
    if (!checkFlowControl(len)) {
        return 0;
    }
    
    // 2. è¿½åŠ æ•°æ®åˆ°ç¼“å†²åŒº
    buffer_.append(reinterpret_cast<const uint8_t*>(data), len);
    
    // 3. è§£æåè®®æ•°æ®
    while (/* æœ‰å®Œæ•´æ¶ˆæ¯ */) {
        // è§£ææ¶ˆæ¯
        // è°ƒç”¨å›è°ƒå‡½æ•°
        // æ¸…ç†å·²å¤„ç†æ•°æ®
    }
    
    return processedBytes;
}
```

#### **B. æ•°æ®å°åŒ…å¤„ç†**
```cpp
bool YourProtocol::pack(const char* data, size_t len, std::vector<char>& out) {
    // 1. æµé‡æ§åˆ¶æ£€æŸ¥
    if (!checkFlowControl(len)) {
        return false;
    }
    
    // 2. æ„å»ºåè®®æ ¼å¼
    std::string protocolData = buildProtocolFormat(data, len);
    
    // 3. è¾“å‡ºåˆ°ç¼“å†²åŒº
    out.assign(protocolData.begin(), protocolData.end());
    return true;
}
```

### **4. åè®®ç‰¹å®šåŠŸèƒ½**

æ ¹æ®åè®®ç‰¹ç‚¹ï¼Œæ·»åŠ ç‰¹å®šçš„åŠŸèƒ½æ–¹æ³•ï¼š

```cpp
// HTTPåè®®ç‰¹æœ‰æ–¹æ³•
bool packRequest(Method method, const std::string& path, 
                const std::map<std::string, std::string>& headers,
                const std::string& body, std::vector<char>& out);

bool packResponse(StatusCode statusCode, 
                const std::map<std::string, std::string>& headers,
                const std::string& body, std::vector<char>& out);
```

## ğŸ”§ **HTTPåè®®å®ç°ç¤ºä¾‹**

### **åè®®ç‰¹ç‚¹åˆ†æ**

HTTPåè®®å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š
- **æ–‡æœ¬åè®®**ï¼šåŸºäºASCIIæ–‡æœ¬ï¼Œæ˜“äºè°ƒè¯•
- **è¯·æ±‚-å“åº”æ¨¡å¼**ï¼šå®¢æˆ·ç«¯è¯·æ±‚ï¼ŒæœåŠ¡å™¨å“åº”
- **æ— çŠ¶æ€**ï¼šæ¯ä¸ªè¯·æ±‚ç‹¬ç«‹å¤„ç†
- **å¯æ‰©å±•**ï¼šæ”¯æŒè‡ªå®šä¹‰å¤´éƒ¨å’Œæ‰©å±•

### **æ ¸å¿ƒå®ç°è¦ç‚¹**

#### **1. æ¶ˆæ¯è§£æ**
```cpp
// è§£æHTTPå¤´éƒ¨
bool parseHeaders(const std::vector<std::string>& headerLines, 
                 std::map<std::string, std::string>& headers);

// è§£æè¯·æ±‚è¡Œ
bool parseRequestLine(const std::string& line, HttpRequest& request);

// è§£æå“åº”è¡Œ
bool parseResponseLine(const std::string& line, HttpResponse& response);
```

#### **2. çŠ¶æ€ç®¡ç†**
```cpp
bool parsingHeaders_ = true;      // æ˜¯å¦æ­£åœ¨è§£æå¤´éƒ¨
bool parsingBody_ = false;        // æ˜¯å¦æ­£åœ¨è§£æä½“
bool messageComplete_ = false;    // æ¶ˆæ¯æ˜¯å¦å®Œæ•´
size_t expectedBodyLength_ = 0;   // æœŸæœ›çš„ä½“é•¿åº¦
```

#### **3. é”™è¯¯å¤„ç†**
```cpp
// æ£€æŸ¥è¯·æ±‚å¤§å°
if (buffer_.size() > maxRequestSize_) {
    if (errorCallback_) {
        errorCallback_("HTTP: Request too large");
    }
    reset();
    return 0;
}
```

## ğŸ“Š **åè®®æ‰©å±•å¯¹æ¯”**

| åè®®ç±»å‹ | ç‰¹ç‚¹ | å®ç°å¤æ‚åº¦ | ä½¿ç”¨åœºæ™¯ |
|---------|------|-----------|----------|
| SimpleHeader | äºŒè¿›åˆ¶ï¼Œå›ºå®šåŒ…å¤´ | ç®€å• | é«˜æ€§èƒ½é€šä¿¡ |
| HTTP | æ–‡æœ¬ï¼Œè¯·æ±‚-å“åº” | ä¸­ç­‰ | WebæœåŠ¡ |
| WebSocket | äºŒè¿›åˆ¶ï¼ŒåŒå‘é€šä¿¡ | å¤æ‚ | å®æ—¶é€šä¿¡ |
| MQTT | äºŒè¿›åˆ¶ï¼Œå‘å¸ƒ-è®¢é˜… | å¤æ‚ | IoTè®¾å¤‡ |

## ğŸš€ **æ‰©å±•å…¶ä»–åè®®**

### **WebSocketåè®®æ‰©å±•**

```cpp
class WebSocketProtocol : public ProtocolBase {
public:
    static constexpr uint32_t ID = 3;
    
    enum class Opcode {
        CONTINUATION = 0x0,
        TEXT = 0x1,
        BINARY = 0x2,
        CLOSE = 0x8,
        PING = 0x9,
        PONG = 0xA
    };
    
    // WebSocketæ¡æ‰‹
    bool handleHandshake(const std::string& request);
    
    // å°åŒ…WebSocketæ¶ˆæ¯
    bool packMessage(Opcode opcode, const std::string& payload, 
                   std::vector<char>& out);
};
```

### **MQTTåè®®æ‰©å±•**

```cpp
class MqttProtocol : public ProtocolBase {
public:
    static constexpr uint32_t ID = 4;
    
    enum class PacketType {
        CONNECT = 1,
        CONNACK = 2,
        PUBLISH = 3,
        PUBACK = 4,
        SUBSCRIBE = 8,
        SUBACK = 9,
        PINGREQ = 12,
        PINGRESP = 13,
        DISCONNECT = 14
    };
    
    // MQTTè¿æ¥
    bool packConnect(const std::string& clientId, 
                    const std::string& username,
                    const std::string& password,
                    std::vector<char>& out);
    
    // MQTTå‘å¸ƒ
    bool packPublish(const std::string& topic, 
                    const std::string& payload,
                    uint16_t packetId,
                    std::vector<char>& out);
};
```

## ğŸ§ª **æµ‹è¯•ç­–ç•¥**

### **1. å•å…ƒæµ‹è¯•**
```cpp
// æµ‹è¯•åè®®è§£æ
TEST(HttpProtocolTest, ParseGetRequest) {
    HttpProtocol protocol;
    std::string request = "GET /api/test HTTP/1.1\r\n\r\n";
    
    size_t processed = protocol.onDataReceived(request.c_str(), request.length());
    EXPECT_EQ(processed, request.length());
    EXPECT_TRUE(protocol.isComplete());
}
```

### **2. é›†æˆæµ‹è¯•**
```cpp
// æµ‹è¯•å®Œæ•´æµç¨‹
TEST(HttpProtocolTest, CompleteFlow) {
    HttpProtocol protocol;
    
    // è®¾ç½®å›è°ƒ
    protocol.setPacketCallback([](const std::vector<char>& packet) {
        // éªŒè¯è§£æç»“æœ
    });
    
    // å‘é€æµ‹è¯•æ•°æ®
    std::string testData = "HTTP/1.1 200 OK\r\n\r\n";
    protocol.onDataReceived(testData.c_str(), testData.length());
}
```

### **3. æ€§èƒ½æµ‹è¯•**
```cpp
// æµ‹è¯•ååé‡
TEST(HttpProtocolTest, Throughput) {
    HttpProtocol protocol;
    
    // å‘é€å¤§é‡è¯·æ±‚
    for (int i = 0; i < 10000; ++i) {
        std::string request = "GET /api/test HTTP/1.1\r\n\r\n";
        protocol.onDataReceived(request.c_str(), request.length());
    }
    
    // éªŒè¯æ€§èƒ½æŒ‡æ ‡
}
```

## ğŸ“ˆ **æ€§èƒ½ä¼˜åŒ–å»ºè®®**

### **1. å†…å­˜ä¼˜åŒ–**
- ä½¿ç”¨å†…å­˜æ± ç®¡ç†ç¼“å†²åŒº
- é¿å…é¢‘ç¹çš„å†…å­˜åˆ†é…
- é¢„åˆ†é…è¶³å¤Ÿçš„å†…å­˜ç©ºé—´

### **2. è§£æä¼˜åŒ–**
- ä½¿ç”¨çŠ¶æ€æœºè¿›è¡Œè§£æ
- æ‰¹é‡å¤„ç†æ•°æ®
- å‡å°‘å­—ç¬¦ä¸²æ‹·è´

### **3. å¹¶å‘ä¼˜åŒ–**
- ä½¿ç”¨æ— é”æ•°æ®ç»“æ„
- å‡å°‘é”ç«äº‰
- ä¼˜åŒ–çº¿ç¨‹äº²å’Œæ€§

## ğŸ”„ **é›†æˆåˆ°æ¡†æ¶**

### **1. æ›´æ–°åè®®å·¥å‚**
```cpp
// åœ¨ProtocolFactoryä¸­æ·»åŠ æ–°åè®®
std::unique_ptr<ProtocolBase> createProtocol(uint32_t protocolId) {
    switch (protocolId) {
        case 1: return std::make_unique<SimpleHeaderProtocol>();
        case 2: return std::make_unique<HttpProtocol>();
        case 3: return std::make_unique<WebSocketProtocol>();
        case 4: return std::make_unique<MqttProtocol>();
        default: return nullptr;
    }
}
```

### **2. æ›´æ–°æœåŠ¡å™¨é…ç½®**
```cpp
// åœ¨é…ç½®æ–‡ä»¶ä¸­æ·»åŠ åè®®æ”¯æŒ
[protocols]
simple_header = 1
http = 2
websocket = 3
mqtt = 4
```

### **3. æ·»åŠ è·¯ç”±æ”¯æŒ**
```cpp
// æ ¹æ®åè®®ç±»å‹è·¯ç”±åˆ°ä¸åŒçš„å¤„ç†å™¨
void handleConnection(Connection* conn) {
    switch (conn->getProtocolId()) {
        case 1: handleSimpleHeader(conn); break;
        case 2: handleHttp(conn); break;
        case 3: handleWebSocket(conn); break;
        case 4: handleMqtt(conn); break;
    }
}
```

## ğŸ“ **æ€»ç»“**

åè®®æ‰©å±•çš„å…³é”®è¦ç‚¹ï¼š

1. **ç»§æ‰¿åŸºç±»**ï¼šæ‰€æœ‰åè®®éƒ½å¿…é¡»ç»§æ‰¿`ProtocolBase`
2. **å®ç°æ¥å£**ï¼šå¿…é¡»å®ç°æ‹†åŒ…ã€å°åŒ…ã€ç±»å‹è¯†åˆ«ç­‰æ ¸å¿ƒæ¥å£
3. **çŠ¶æ€ç®¡ç†**ï¼šæ­£ç¡®ç®¡ç†åè®®è§£æçŠ¶æ€
4. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯æ£€æµ‹å’Œå¤„ç†æœºåˆ¶
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šä½¿ç”¨å†…å­˜æ± ã€å‡å°‘æ‹·è´ã€ä¼˜åŒ–è§£æ
6. **æµ‹è¯•éªŒè¯**ï¼šå…¨é¢çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
7. **æ¡†æ¶é›†æˆ**ï¼šæ›´æ–°å·¥å‚ã€é…ç½®ã€è·¯ç”±ç­‰æ¡†æ¶ç»„ä»¶

é€šè¿‡è¿™ç§æ–¹å¼ï¼Œå¯ä»¥è½»æ¾åœ°åœ¨NetBoxé¡¹ç›®ä¸­æ‰©å±•å„ç§åè®®æ”¯æŒï¼Œæ»¡è¶³ä¸åŒçš„åº”ç”¨éœ€æ±‚ã€‚ 