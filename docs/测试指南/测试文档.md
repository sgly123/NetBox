# NetBox框架测试指南

## 1. 测试类型

### 1.1 单元测试
- 使用Google Test框架
- 测试各个组件的独立功能
- 位于 `tests/unit/` 目录

### 1.2 集成测试
- 测试组件间的交互
- 测试完整的功能流程
- 位于 `tests/integration/` 目录

### 1.3 性能测试
- 测试系统在不同负载下的表现
- 包括吞吐量、延迟等指标
- 位于 `tests/performance/` 目录

## 2. 测试工具

### 2.1 测试脚本
```bash
# Echo服务器测试
./test_echo.sh

# HTTP协议测试
./test_http_protocol.sh

# 改进协议测试
./test_improved.py

# 快速测试
./quick_test.py
```

### 2.2 性能分析工具
```bash
# 系统优化脚本
./optimize_system.sh

# 异步日志测试
./test_async_logger
```

## 3. 单元测试示例

### 3.1 协议测试
```cpp
TEST(ProtocolTest, SimpleHeaderProtocol) {
    SimpleHeaderProtocol proto;
    std::string testData = "Hello, World!";
    std::vector<char> packet;
    
    // 测试打包
    EXPECT_TRUE(proto.pack(testData.data(), testData.size(), packet));
    
    // 测试解包
    std::vector<char> unpackedData;
    EXPECT_TRUE(proto.unpack(packet.data(), packet.size(), unpackedData));
    
    // 验证数据
    std::string result(unpackedData.begin(), unpackedData.end());
    EXPECT_EQ(testData, result);
}
```

### 3.2 服务器测试
```cpp
TEST(ServerTest, StartStop) {
    EchoServer server("127.0.0.1", 8888);
    
    // 测试启动
    EXPECT_TRUE(server.start());
    
    // 测试连接
    Client client;
    EXPECT_TRUE(client.connect("127.0.0.1", 8888));
    
    // 测试停止
    server.stop();
    EXPECT_FALSE(client.isConnected());
}
```

## 4. 集成测试示例

### 4.1 完整流程测试
```python
def test_full_flow():
    # 启动服务器
    server = start_server()
    
    # 创建客户端
    client = create_client()
    
    # 测试连接
    assert client.connect()
    
    # 发送数据
    data = "Test Message"
    assert client.send(data)
    
    # 接收响应
    response = client.receive()
    assert response == "Echo: " + data
    
    # 清理
    client.close()
    server.stop()
```

### 4.2 压力测试
```python
def test_concurrent_connections():
    server = start_server()
    clients = []
    
    # 创建多个客户端
    for i in range(1000):
        client = create_client()
        assert client.connect()
        clients.append(client)
    
    # 并发发送数据
    data = "Test Message"
    for client in clients:
        client.send_async(data)
    
    # 验证响应
    for client in clients:
        response = client.receive()
        assert response == "Echo: " + data
    
    # 清理
    for client in clients:
        client.close()
    server.stop()
```

## 5. 性能测试指标

### 5.1 吞吐量测试
```bash
# 测试不同消息大小的吞吐量
for size in 64 256 1024 4096 16384; do
    ./test_throughput.py --size $size --duration 60
done
```

### 5.2 延迟测试
```bash
# 测试不同并发度下的延迟
for clients in 1 10 50 100 500; do
    ./test_latency.py --clients $clients --requests 1000
done
```

## 6. 测试报告

### 6.1 性能指标
- 单连接吞吐量: 100MB/s
- 最大并发连接: 10000
- 平均响应时间: <1ms
- CPU使用率: <50%
- 内存使用: <100MB

### 6.2 稳定性指标
- 24小时无错误运行
- 内存泄漏: 无
- 文件描述符泄漏: 无
- 连接泄漏: 无

## 7. 测试最佳实践

1. **测试覆盖率**
   - 使用gcov统计覆盖率
   - 核心代码覆盖率>80%
   - 关键路径覆盖率100%

2. **测试数据**
   - 使用真实场景数据
   - 包含边界条件
   - 包含错误情况

3. **测试环境**
   - 独立的测试环境
   - 固定的系统配置
   - 网络隔离

4. **自动化测试**
   - CI/CD集成
   - 定时运行测试
   - 自动生成报告

## 8. 常见问题

### Q1: 测试失败时如何调试？
1. 检查日志文件
2. 使用GDB调试
3. 添加更多日志点

### Q2: 如何添加新的测试用例？
1. 在对应目录创建测试文件
2. 编写测试用例
3. 更新CMakeLists.txt
4. 运行测试

### Q3: 性能测试结果不稳定？
1. 确保测试环境独立
2. 多次运行取平均值
3. 排除外部干扰

## 9. 测试工具链

1. **编译和构建**
   - CMake
   - GCC/Clang
   - Make

2. **测试框架**
   - Google Test
   - Python unittest
   - Shell脚本

3. **性能分析**
   - perf
   - valgrind
   - gprof

4. **代码覆盖率**
   - gcov
   - lcov
   - codecov

## 10. 持续集成

1. **触发条件**
   - 代码提交
   - Pull Request
   - 定时任务

2. **测试流程**
   - 编译检查
   - 单元测试
   - 集成测试
   - 性能测试

3. **报告生成**
   - 测试结果
   - 覆盖率报告
   - 性能指标 