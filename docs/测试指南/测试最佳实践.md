# NetBox 测试最佳实践指南

## 概述

本文档提供了在NetBox项目中编写和维护单元测试的最佳实践指南，帮助开发者编写高质量、可维护的测试代码。

## 测试编写原则

### 1. FIRST原则
- **Fast (快速)**: 测试应该快速执行
- **Independent (独立)**: 测试之间不应该相互依赖
- **Repeatable (可重复)**: 测试结果应该一致
- **Self-Validating (自验证)**: 测试应该有明确的通过/失败结果
- **Timely (及时)**: 测试应该与代码同时编写

### 2. AAA模式
每个测试用例应该遵循AAA模式：
- **Arrange (准备)**: 设置测试数据和环境
- **Act (执行)**: 执行被测试的功能
- **Assert (断言)**: 验证结果

```cpp
TEST_F(MyClassTest, ShouldReturnCorrectValue) {
    // Arrange
    MyClass obj;
    int input = 42;
    int expected = 84;
    
    // Act
    int result = obj.doubleValue(input);
    
    // Assert
    EXPECT_EQ(result, expected);
}
```

## 测试命名规范

### 测试类命名
```cpp
// 格式: [被测试类名]Test
class LoggerTest : public ::testing::Test { };
class ThreadPoolTest : public ::testing::Test { };
```

### 测试方法命名
使用描述性的名称，说明测试的场景和期望：
```cpp
// 好的命名
TEST_F(LoggerTest, ShouldLogMessageWithCorrectLevel)
TEST_F(ThreadPoolTest, ShouldRejectTaskWhenQueueIsFull)
TEST_F(ConfigReaderTest, ShouldReturnDefaultValueWhenKeyNotFound)

// 避免的命名
TEST_F(LoggerTest, Test1)
TEST_F(ThreadPoolTest, BasicTest)
```

## 测试结构最佳实践

### 1. 使用测试夹具(Test Fixture)
```cpp
class MyClassTest : public ::testing::Test {
protected:
    void SetUp() override {
        // 每个测试前的初始化
        obj_ = std::make_unique<MyClass>();
        test_data_ = createTestData();
    }

    void TearDown() override {
        // 每个测试后的清理
        obj_.reset();
        cleanupTestData();
    }

    std::unique_ptr<MyClass> obj_;
    TestData test_data_;
};
```

### 2. 使用参数化测试
对于需要测试多种输入的场景：
```cpp
class MathTest : public ::testing::TestWithParam<std::pair<int, int>> {
};

TEST_P(MathTest, Addition) {
    auto [a, b] = GetParam();
    EXPECT_EQ(add(a, b), a + b);
}

INSTANTIATE_TEST_SUITE_P(
    AdditionTests,
    MathTest,
    ::testing::Values(
        std::make_pair(1, 2),
        std::make_pair(-1, 1),
        std::make_pair(0, 0)
    )
);
```

### 3. 使用自定义断言
为复杂的验证逻辑创建自定义断言：
```cpp
::testing::AssertionResult IsValidConfig(const Config& config) {
    if (config.port <= 0) {
        return ::testing::AssertionFailure() << "Port must be positive";
    }
    if (config.host.empty()) {
        return ::testing::AssertionFailure() << "Host cannot be empty";
    }
    return ::testing::AssertionSuccess();
}

TEST_F(ConfigTest, ShouldCreateValidConfig) {
    Config config = createConfig();
    EXPECT_TRUE(IsValidConfig(config));
}
```

## 多线程测试最佳实践

### 1. 使用同步原语
```cpp
TEST_F(ThreadPoolTest, MultiThreadSafety) {
    const int thread_count = 10;
    const int operations_per_thread = 100;
    std::atomic<int> counter{0};
    std::vector<std::thread> threads;
    
    for (int i = 0; i < thread_count; ++i) {
        threads.emplace_back([&]() {
            for (int j = 0; j < operations_per_thread; ++j) {
                pool_.enqueue([&counter]() {
                    counter.fetch_add(1);
                });
            }
        });
    }
    
    for (auto& thread : threads) {
        thread.join();
    }
    
    // 等待所有任务完成
    TestUtils::waitForCondition([&]() {
        return counter.load() == thread_count * operations_per_thread;
    }, 5000);
    
    EXPECT_EQ(counter.load(), thread_count * operations_per_thread);
}
```

### 2. 避免时序依赖
```cpp
// 不好的做法
TEST_F(AsyncTest, BadTimingTest) {
    startAsyncOperation();
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 硬编码等待
    EXPECT_TRUE(isOperationComplete());
}

// 好的做法
TEST_F(AsyncTest, GoodTimingTest) {
    startAsyncOperation();
    EXPECT_TIMEOUT(isOperationComplete(), 1000); // 使用条件等待
}
```

## 测试数据管理

### 1. 使用测试工具类
```cpp
class TestDataBuilder {
public:
    static Config createValidConfig() {
        Config config;
        config.host = "127.0.0.1";
        config.port = 8080;
        config.timeout = 30;
        return config;
    }
    
    static Config createInvalidConfig() {
        Config config;
        config.host = "";
        config.port = -1;
        return config;
    }
};
```

### 2. 使用临时文件
```cpp
TEST_F(FileTest, ShouldReadConfigFromFile) {
    // 创建临时测试文件
    std::string test_file = TestUtils::getTestDataDir() + "test_config.txt";
    ASSERT_TRUE(TestUtils::createTempFile(test_file, "host=localhost\nport=8080"));
    
    // 执行测试
    Config config = ConfigReader::loadFromFile(test_file);
    
    // 验证结果
    EXPECT_EQ(config.host, "localhost");
    EXPECT_EQ(config.port, 8080);
    
    // 清理
    TestUtils::removeTempFile(test_file);
}
```

## 性能测试最佳实践

### 1. 使用性能测试基类
```cpp
class MyPerformanceTest : public PerformanceTestBase {
protected:
    void SetUp() override {
        PerformanceTestBase::SetUp();
        // 性能测试特定的设置
    }
};

TEST_F(MyPerformanceTest, ShouldCompleteWithinTimeLimit) {
    const int iterations = 10000;
    
    EXPECT_EXECUTION_TIME_LESS_THAN({
        for (int i = 0; i < iterations; ++i) {
            performOperation();
        }
    }, 1000.0); // 应该在1秒内完成
}
```

### 2. 测量和报告性能指标
```cpp
TEST_F(PerformanceTest, ThroughputTest) {
    const int operations = 100000;
    
    double execution_time = TestUtils::measureExecutionTime([&]() {
        for (int i = 0; i < operations; ++i) {
            processItem();
        }
    });
    
    double throughput = operations / (execution_time / 1000.0); // ops/sec
    std::cout << "Throughput: " << throughput << " ops/sec" << std::endl;
    
    // 设置性能基准
    EXPECT_GT(throughput, 10000.0); // 至少10K ops/sec
}
```

## 错误处理测试

### 1. 测试异常情况
```cpp
TEST_F(MyClassTest, ShouldThrowExceptionForInvalidInput) {
    EXPECT_THROW(obj_->processInvalidInput(), std::invalid_argument);
}

TEST_F(MyClassTest, ShouldHandleNullPointer) {
    EXPECT_NO_THROW(obj_->processNullPointer(nullptr));
}
```

### 2. 测试边界条件
```cpp
TEST_F(BufferTest, ShouldHandleBoundaryConditions) {
    Buffer buffer(10);
    
    // 测试空缓冲区
    EXPECT_TRUE(buffer.empty());
    EXPECT_EQ(buffer.size(), 0);
    
    // 测试满缓冲区
    buffer.fill();
    EXPECT_TRUE(buffer.full());
    EXPECT_EQ(buffer.size(), 10);
    
    // 测试溢出
    EXPECT_FALSE(buffer.tryAdd("overflow"));
}
```

## 测试维护指南

### 1. 定期重构测试代码
- 消除重复代码
- 提取公共测试逻辑
- 更新过时的测试

### 2. 保持测试与代码同步
- 代码重构时同步更新测试
- 新功能必须包含测试
- 删除无用的测试

### 3. 监控测试质量
- 定期检查测试覆盖率
- 分析失败测试的原因
- 优化慢速测试

## 常见陷阱和解决方案

### 1. 测试间相互依赖
```cpp
// 错误：测试依赖全局状态
static int global_counter = 0;

TEST(BadTest, Test1) {
    global_counter++;
    EXPECT_EQ(global_counter, 1);
}

TEST(BadTest, Test2) {
    global_counter++; // 依赖Test1的结果
    EXPECT_EQ(global_counter, 2);
}

// 正确：每个测试独立
TEST_F(GoodTest, Test1) {
    int counter = 0;
    counter++;
    EXPECT_EQ(counter, 1);
}

TEST_F(GoodTest, Test2) {
    int counter = 0;
    counter++;
    EXPECT_EQ(counter, 1);
}
```

### 2. 过度使用Mock
```cpp
// 过度Mock - 测试变得脆弱
TEST_F(OverMockedTest, BadExample) {
    EXPECT_CALL(mock_a, method1()).Times(1);
    EXPECT_CALL(mock_b, method2()).Times(1);
    EXPECT_CALL(mock_c, method3()).Times(1);
    // ... 太多的Mock期望
}

// 适度Mock - 只Mock必要的依赖
TEST_F(WellMockedTest, GoodExample) {
    EXPECT_CALL(external_service, getData())
        .WillOnce(Return(test_data));
    
    auto result = service_under_test.process();
    EXPECT_EQ(result.status, "success");
}
```

## 总结

遵循这些最佳实践可以帮助你编写高质量、可维护的测试代码：

1. **保持测试简单和专注**
2. **使用描述性的命名**
3. **确保测试独立性**
4. **适当处理异步和多线程场景**
5. **定期维护和重构测试代码**

好的测试不仅能发现bug，还能作为代码的活文档，帮助其他开发者理解代码的预期行为。
