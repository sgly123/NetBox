# 🎮 三国杀算法训练系统设计

> **创新项目：** 将枯燥的算法题包装成有趣的三国杀游戏场景，寓教于乐的算法学习平台

---

## 🎯 项目概念

### 核心理念
将LeetCode经典题目包装成三国杀的故事情节和游戏机制，让学习算法变得像玩游戏一样有趣。

### 技术价值
- **算法能力提升**：通过游戏化方式掌握核心算法
- **项目开发经验**：完整的教育类游戏开发
- **用户体验设计**：寓教于乐的产品设计思维

---

## 🏗️ 系统架构

### 整体设计
```
┌─────────────────────────────────────────────────────────┐
│                Qt游戏客户端                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐   │
│  │  游戏界面   │ │  算法编辑器 │ │  进度追踪系统   │   │
│  │   Layer     │ │   Layer     │ │     Layer       │   │
│  └─────────────┘ └─────────────┘ └─────────────────┘   │
│  ┌─────────────────────────────────────────────────┐   │
│  │              算法评测引擎                         │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                            │ 
                            ▼
┌─────────────────────────────────────────────────────────┐
│              NetBox算法服务器                            │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐   │
│  │  题库管理   │ │  代码评测   │ │    排行榜       │   │
│  │   Module    │ │   Engine    │ │     System      │   │
│  └─────────────┘ └─────────────┘ └─────────────────┘   │
│  ┌─────────────────────────────────────────────────┐   │
│  │              NetBox网络框架                       │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

---

## 🎭 游戏化算法题目设计

### 1. 数组与字符串类 - "兵法排阵"

#### 🏹 两数之和 → "双箭齐发"
**背景故事**：
```
黄忠需要在军营中选择两名弓箭手，使得他们的箭术值之和等于目标值，
才能完成"双箭齐发"的合击技能。
```

**游戏界面**：
```cpp
// 算法题界面设计
class ShuangJianQiFa : public AlgorithmChallenge {
private:
    std::vector<int> archerSkills_;  // 弓箭手技能值数组
    int targetSum_;                   // 目标合击值
    
public:
    QString getStoryText() override {
        return "黄忠军营中有若干弓箭手，每人箭术值不同。\n"
               "需要找到两人的箭术值之和等于" + QString::number(targetSum_) + 
               "，以释放双箭齐发技能！";
    }
    
    void showVisualization() override {
        // 显示弓箭手阵列，用户可以点击选择
        drawArcherArray(archerSkills_);
    }
};
```

#### 🔄 反转字符串 → "八卦阵法逆转"
**背景故事**：
```
诸葛亮布置的八卦阵被敌军破解，需要将阵法顺序完全反转，
重新布置迷惑敌军。
```

### 2. 链表类 - "铁索连环"

#### ⛓️ 反转链表 → "铁索连环反攻"
**背景故事**：
```
庞统设计的铁索连环被识破，曹操的战船已经用铁链相连。
现在需要改变连接顺序，将战船阵型完全反转！
```

**可视化设计**：
```cpp
class TieSuoLianHuan : public AlgorithmChallenge {
    struct WarShip {
        int id;
        std::shared_ptr<WarShip> next;
        QPoint position;        // 界面位置
        QString generalName;    // 船上的将领
    };
    
    void animateReversal() {
        // 动画展示链表反转过程
        for (auto ship : ships_) {
            moveShipToNewPosition(ship, calculateReversedPosition(ship));
        }
    }
};
```

### 3. 树类 - "家族世系"

#### 🌳 二叉树遍历 → "家族族谱查询"
**背景故事**：
```
刘备需要查询刘氏皇族的族谱，寻找合适的继承人。
族谱以树状结构记录，需要按照特定顺序遍历所有族人。
```

**界面设计**：
```cpp
class FamilyTree : public AlgorithmChallenge {
    struct FamilyMember {
        QString name;
        int generation;         // 辈分
        QPixmap portrait;       // 头像
        std::shared_ptr<FamilyMember> left, right;
    };
    
    void drawFamilyTree() {
        // 绘制可视化的家族树
        drawTreeNode(root_, QPoint(400, 50));
    }
    
    void highlightTraversalPath(TraversalType type) {
        // 高亮显示遍历路径
        switch(type) {
            case PREORDER:  // 先序：长辈优先
            case INORDER:   // 中序：按辈分排序  
            case POSTORDER: // 后序：子孙优先
        }
    }
};
```

### 4. 动态规划类 - "谋略决策"

#### 💰 背包问题 → "军资调配"
**背景故事**：
```
诸葛亮需要为北伐准备军资，军库中有各种装备，每种装备有重量和价值。
马车载重有限，如何选择装备使得总价值最大？
```

**游戏机制**：
```cpp
class JunZiDiaoPei : public AlgorithmChallenge {
    struct Equipment {
        QString name;           // 装备名称
        int weight;            // 重量
        int value;             // 价值
        QPixmap icon;          // 图标
        QString description;   // 描述
    };
    
    void showEquipmentSelection() {
        // 显示装备选择界面
        for (auto& eq : equipments_) {
            drawEquipmentCard(eq);
        }
        
        // 显示当前背包状态
        drawBagStatus(currentWeight_, maxWeight_);
        drawValueMeter(currentValue_);
    }
};
```

### 5. 图论类 - "地理攻防"

#### 🗺️ 最短路径 → "行军路线规划"
**背景故事**：
```
关羽需要从荆州赶往成都支援，地图上有多条路径。
考虑到路途的距离和危险程度，需要找到最优路线。
```

**地图界面**：
```cpp
class XingJunLuXian : public AlgorithmChallenge {
    struct City {
        QString name;
        QPoint mapPosition;
        std::vector<Road> roads;
    };
    
    struct Road {
        int to;                // 目标城市
        int distance;          // 距离
        int danger;            // 危险度
        QString terrainType;   // 地形类型
    };
    
    void drawStrategyMap() {
        // 绘制三国地图
        drawMapBackground();
        
        for (auto& city : cities_) {
            drawCityIcon(city);
        }
        
        for (auto& road : allRoads_) {
            drawRoadConnection(road);
        }
    }
    
    void animatePathFinding() {
        // 动画显示路径搜索过程
        highlightSearchingPath();
        showOptimalRoute();
    }
};
```

---

## 🎯 学习系统设计

### 进度追踪系统
```cpp
class LearningProgress {
private:
    struct Achievement {
        QString title;          // 成就名称："智谋超群"
        QString description;    // 描述："完成所有DP题目"
        QPixmap badge;          // 徽章图标
        bool unlocked;          // 是否解锁
    };
    
    std::map<AlgorithmType, int> masteryLevel_;  // 各算法掌握度
    std::vector<Achievement> achievements_;       // 成就系统
    
public:
    void updateProgress(AlgorithmType type) {
        masteryLevel_[type]++;
        checkAchievements();
        updateCharacterLevel();  // 更新角色等级
    }
};
```

### 排行榜系统
```cpp
class LeaderBoard {
    struct PlayerRanking {
        QString playerName;     // 玩家名
        QString title;          // 称号："卧龙"、"凤雏"
        int totalScore;         // 总分
        int problemsSolved;     // 解题数
        QString favoriteHero;   // 最爱武将
    };
    
    void updateRanking() {
        // 实时更新排行榜
        // 基于NetBox网络框架实现多人竞技
    }
};
```

---

## 💻 技术实现方案

### 代码编辑器集成
```cpp
class CodeEditor : public QTextEdit {
private:
    SyntaxHighlighter* highlighter_;    // 语法高亮
    AutoCompleter* completer_;          // 代码补全
    
public:
    void setTheme(ThemeType theme) {
        switch(theme) {
            case SANGUOSHA_CLASSIC:  // 三国杀经典主题
                setClassicTheme();
                break;
            case ZHUGE_LIANG:        // 诸葛亮智慧主题
                setWisdomTheme();
                break;
        }
    }
    
    void runAlgorithm() {
        QString code = this->toPlainText();
        
        // 基于NetBox的代码评测服务
        AlgorithmJudge judge;
        auto result = judge.evaluate(code, currentProblem_);
        
        showResult(result);
        updateGameProgress(result);
    }
};
```

### 算法可视化引擎
```cpp
class AlgorithmVisualizer {
public:
    void visualizeSorting(std::vector<int>& arr, SortType type) {
        switch(type) {
            case BUBBLE_SORT:
                animateBubbleSort(arr);  // 气泡排序动画
                break;
            case QUICK_SORT:
                animateQuickSort(arr);   // 快排分治动画
                break;
        }
    }
    
    void visualizePathFinding(Graph& graph, int start, int end) {
        // 可视化路径搜索算法
        highlightSearchProcess();
        showOptimalPath();
    }
};
```

---

## 🎮 游戏机制设计

### 角色成长系统
```cpp
enum class HeroType {
    ZHUGE_LIANG,    // 诸葛亮 - DP专家
    GUAN_YU,        // 关羽 - 图论专家  
    ZHAO_YUN,       // 赵云 - 搜索专家
    HUANG_ZHONG     // 黄忠 - 数组专家
};

class GameCharacter {
private:
    HeroType heroType_;
    int level_;
    std::map<AlgorithmType, int> specialtyBonus_;  // 专业加成
    
public:
    void levelUp(AlgorithmType type) {
        if (isSpecialty(type)) {
            level_ += 2;  // 专业领域双倍经验
        } else {
            level_ += 1;
        }
        
        unlockNewSkills();
    }
};
```

### 挑战模式
```cpp
class ChallengeMode {
public:
    // 每日挑战
    void dailyChallenge() {
        auto problem = generateDailyProblem();
        showChallengeStory(problem);
    }
    
    // 限时竞技
    void timeAttack() {
        startTimer(300);  // 5分钟限时
        showRandomProblem();
    }
    
    // 团队协作 (基于NetBox多人功能)
    void teamChallenge() {
        createTeamRoom();
        distributeSubproblems();
    }
};
```

---

## 📋 开发计划

### Phase 1: 核心框架 (2周)
- ✅ 基于NetBox的服务器端
- ✅ Qt客户端基础界面
- ✅ 算法评测引擎

### Phase 2: 游戏化内容 (3周)
- ✅ 20个经典题目的三国杀包装
- ✅ 角色系统和进度追踪
- ✅ 可视化动画引擎

### Phase 3: 高级功能 (2周)
- ✅ 多人竞技模式
- ✅ 成就系统
- ✅ 数据统计分析

---

## 🏆 项目价值

### 校招亮点
1. **创新性**：独特的教育游戏化思路
2. **技术全面性**：网络编程 + GUI + 算法 + 游戏开发
3. **实用价值**：真正能帮助他人学习的产品
4. **商业潜力**：可以发展成创业项目

### 面试话题
- **产品设计思维**：如何让学习变得有趣
- **用户体验**：游戏化学习的心理学原理
- **技术架构**：分布式算法评测系统
- **性能优化**：大量用户同时在线的挑战

---

## 💡 学习建议

### 实施方案
1. **边开发边学算法**：在实现过程中自然掌握各种算法
2. **自己做第一个用户**：用自己的系统来刷题
3. **邀请同学测试**：获得反馈，持续改进

### 时间分配
```
开发系统框架 (30%) + 实现算法题目 (50%) + 优化完善 (20%)
= 学会算法 + 完成项目 + 提升工程能力
```

---

<div align="center">

**🎮 让算法学习变成一场精彩的三国之旅！**

**既能提升技术能力，又能展示产品设计思维** 🚀

</div> 