# 🎮 基于NetBox的三国杀游戏开发计划

> **校招项目二：** 结合Qt GUI和网络编程的完整游戏项目，展示客户端-服务器架构设计能力

---

## 🎯 项目概述

### 项目定位
基于已有的NetBox网络框架，开发一个完整的网络版三国杀游戏，包含：
- **游戏服务器**：基于NetBox框架的多人游戏服务器
- **Qt客户端**：现代化的游戏界面和动画效果
- **实时通信**：支持多人实时对战的网络协议

### 技术价值体现
1. **完整的C/S架构**：从网络底层到UI层的完整实现
2. **Qt GUI开发**：现代化界面设计和动画系统
3. **游戏开发经验**：实时同步、状态管理、复杂逻辑
4. **系统设计能力**：模块化架构、协议设计、性能优化

---

## 🏗️ 项目架构设计

### 整体架构
```
┌─────────────────────────────────────────────────────────┐
│                Qt游戏客户端                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐   │
│  │  游戏界面   │ │  动画引擎   │ │    音效系统     │   │
│  │   Layer     │ │   Layer     │ │     Layer       │   │
│  └─────────────┘ └─────────────┘ └─────────────────┘   │
│  ┌─────────────────────────────────────────────────┐   │
│  │              网络通信层                           │   │
│  │         (QTcpSocket + 自定义协议)                 │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                            │ TCP Connection
                            ▼
┌─────────────────────────────────────────────────────────┐
│                NetBox游戏服务器                          │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐   │
│  │  房间管理   │ │  游戏逻辑   │ │    状态同步     │   │
│  │   Module    │ │   Engine    │ │     Module      │   │
│  └─────────────┘ └─────────────┘ └─────────────────┘   │
│  ┌─────────────────────────────────────────────────┐   │
│  │              NetBox网络框架                       │   │
│  │        (协议路由 + IO多路复用 + 线程池)           │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 技术栈选择
- **服务器端**：C++17 + NetBox框架 + 自定义游戏协议
- **客户端**：Qt 6.x + QGraphicsView + QPropertyAnimation
- **网络通信**：TCP Socket + 二进制协议
- **构建系统**：CMake (服务器) + qmake/CMake (客户端)

---

## 📋 详细开发计划

### 🎯 第一阶段：基础框架搭建 (Week 1-2)

#### 1.1 扩展NetBox协议层
```cpp
// 三国杀游戏协议定义
class SgsProtocol : public ProtocolBase {
public:
    // 协议标识符
    static constexpr uint32_t PROTOCOL_ID = 0x53475300; // "SGS\0"
    
    // 消息类型枚举
    enum MessageType : uint16_t {
        // 连接管理
        MSG_LOGIN_REQUEST = 0x1001,
        MSG_LOGIN_RESPONSE = 0x1002,
        MSG_LOGOUT = 0x1003,
        
        // 房间管理
        MSG_CREATE_ROOM = 0x2001,
        MSG_JOIN_ROOM = 0x2002,
        MSG_LEAVE_ROOM = 0x2003,
        MSG_ROOM_INFO = 0x2004,
        
        // 游戏流程
        MSG_GAME_START = 0x3001,
        MSG_CHOOSE_GENERAL = 0x3002,
        MSG_GAME_STATE_SYNC = 0x3003,
        
        // 卡牌操作
        MSG_PLAY_CARD = 0x4001,
        MSG_USE_SKILL = 0x4002,
        MSG_RESPONSE_CARD = 0x4003,
        
        // 游戏结算
        MSG_ROUND_END = 0x5001,
        MSG_GAME_END = 0x5002
    };
    
    size_t onDataReceived(const char* data, size_t len) override;
    bool pack(const char* data, size_t len, std::vector<char>& out) override;
};
```

#### 1.2 游戏服务器核心模块
```cpp
// 游戏服务器主类
class SgsGameServer : public ApplicationServer {
private:
    std::unordered_map<std::string, std::shared_ptr<GameRoom>> rooms_;
    std::unordered_map<int, std::shared_ptr<Player>> onlinePlayers_;
    std::atomic<uint32_t> nextRoomId_{1000};
    
public:
    void onPacketReceived(const std::vector<char>& packet) override;
    void onClientConnected(int clientFd) override;
    void onClientDisconnected(int clientFd) override;
    
    // 房间管理
    std::string createRoom(int creatorFd, const RoomSettings& settings);
    bool joinRoom(int playerFd, const std::string& roomId);
    void leaveRoom(int playerFd);
    
    // 消息分发
    void broadcastToRoom(const std::string& roomId, const std::vector<char>& message);
    void sendToPlayer(int playerFd, const std::vector<char>& message);
};

// 游戏房间类
class GameRoom {
private:
    std::string roomId_;
    std::vector<std::shared_ptr<Player>> players_;
    std::unique_ptr<GameLogic> gameLogic_;
    RoomState state_ = RoomState::WAITING;
    
public:
    bool addPlayer(std::shared_ptr<Player> player);
    void removePlayer(int playerId);
    void startGame();
    void processGameAction(int playerId, const GameAction& action);
    void syncGameState();
};
```

#### 1.3 Qt客户端基础框架
```cpp
// 主窗口类
class SgsMainWindow : public QMainWindow {
    Q_OBJECT
    
private:
    // UI组件
    QGraphicsView* gameView_;
    QGraphicsScene* gameScene_;
    QWidget* menuWidget_;
    QWidget* gameWidget_;
    
    // 网络组件
    QTcpSocket* tcpSocket_;
    QByteArray receiveBuffer_;
    
    // 游戏状态
    GameClient* gameClient_;
    
public:
    SgsMainWindow(QWidget* parent = nullptr);
    
private slots:
    void onConnectButtonClicked();
    void onSocketConnected();
    void onSocketDisconnected();
    void onSocketReadyRead();
    void onSocketError(QAbstractSocket::SocketError error);
    
    // 游戏事件处理
    void onCardClicked(int cardId);
    void onSkillButtonClicked(int skillId);
    void onConfirmButtonClicked();
};

// 游戏客户端逻辑
class GameClient : public QObject {
    Q_OBJECT
    
private:
    PlayerInfo localPlayer_;
    std::vector<PlayerInfo> allPlayers_;
    GameState currentState_;
    
public:
    void processServerMessage(const QByteArray& message);
    void sendLoginRequest(const QString& username);
    void sendCreateRoom();
    void sendPlayCard(int cardId, int targetId = -1);
    
signals:
    void gameStateChanged(const GameState& state);
    void playerInfoUpdated(const PlayerInfo& player);
    void messageReceived(const QString& message);
};
```

### 🎮 第二阶段：核心游戏逻辑 (Week 3-4)

#### 2.1 游戏数据结构设计
```cpp
// 武将卡数据
struct General {
    int id;
    std::string name;
    std::string title;
    int maxHp;
    std::vector<int> skills;
    std::string description;
    std::string imagePath;
};

// 游戏卡牌数据
struct Card {
    int id;
    CardType type;      // 基本牌、锦囊牌、装备牌
    CardSuit suit;      // 花色：红桃、方片、梅花、黑桃
    int number;         // 点数：1-13
    std::string name;
    std::string effect;
    std::string imagePath;
};

// 玩家状态
struct PlayerInfo {
    int playerId;
    std::string username;
    int generalId;
    int currentHp;
    int maxHp;
    std::vector<int> handCards;
    std::vector<int> equipments;
    PlayerPhase phase;
    bool isAlive;
    QPoint position;    // 在界面上的位置
};

// 游戏状态
struct GameState {
    int currentPlayer;
    PlayerPhase currentPhase;
    std::vector<PlayerInfo> players;
    std::vector<int> discardPile;
    int remainingCards;
    bool gameEnded;
    int winner;
};
```

#### 2.2 游戏逻辑引擎
```cpp
class GameLogic {
private:
    std::vector<std::shared_ptr<Player>> players_;
    std::vector<Card> cardDeck_;
    std::vector<Card> discardPile_;
    int currentPlayerIndex_ = 0;
    PlayerPhase currentPhase_ = PlayerPhase::DRAW;
    
public:
    // 游戏流程控制
    void startGame();
    void nextPhase();
    void nextPlayer();
    bool checkGameEnd();
    
    // 卡牌操作
    void drawCards(int playerId, int count);
    bool playCard(int playerId, int cardId, int targetId = -1);
    bool useSkill(int playerId, int skillId, const std::vector<int>& targets);
    
    // 伤害结算
    void dealDamage(int sourceId, int targetId, int damage, DamageType type);
    void recoverHp(int playerId, int amount);
    
    // 判定和响应
    bool requestResponse(int playerId, CardType requiredType, int timeLimit);
    void processResponse(int playerId, int cardId);
    
    // 状态查询
    GameState getCurrentState() const;
    bool isValidAction(int playerId, const GameAction& action) const;
};
```

#### 2.3 技能系统设计
```cpp
// 技能基类
class Skill {
protected:
    int skillId_;
    std::string name_;
    SkillType type_;    // 主动技能、触发技能、锁定技能
    
public:
    virtual bool canUse(const GameState& state, int playerId) const = 0;
    virtual void execute(GameLogic& logic, int playerId, const std::vector<int>& targets) = 0;
    virtual std::string getDescription() const = 0;
};

// 具体技能实现示例
class GuanxingSkill : public Skill {  // 观星技能
public:
    bool canUse(const GameState& state, int playerId) const override {
        return state.currentPlayer == playerId && 
               state.currentPhase == PlayerPhase::PREPARE;
    }
    
    void execute(GameLogic& logic, int playerId, const std::vector<int>& targets) override {
        // 观看牌堆顶的5张牌，重新排列
        auto topCards = logic.peekTopCards(5);
        // 通知客户端进行排列
        logic.requestCardArrangement(playerId, topCards);
    }
};
```

### 🎨 第三阶段：界面美化和动画 (Week 5-6)

#### 3.1 游戏场景设计
```cpp
class GameScene : public QGraphicsScene {
    Q_OBJECT
    
private:
    // 游戏区域
    QGraphicsRectItem* tableArea_;
    std::vector<PlayerArea*> playerAreas_;
    CardPile* drawPile_;
    CardPile* discardPile_;
    
    // 动画管理器
    CardAnimationManager* animationManager_;
    EffectManager* effectManager_;
    
public:
    void setupGameBoard(int playerCount);
    void updatePlayerInfo(int playerId, const PlayerInfo& info);
    void playCardAnimation(int cardId, const QPointF& from, const QPointF& to);
    void showSkillEffect(int skillId, const QRectF& area);
    
private slots:
    void onCardClicked(int cardId);
    void onPlayerAreaClicked(int playerId);
    void onAnimationFinished();
};

// 玩家区域组件
class PlayerArea : public QGraphicsItemGroup {
private:
    int playerId_;
    QGraphicsPixmapItem* avatar_;          // 头像
    QGraphicsTextItem* nameLabel_;         // 玩家名
    QGraphicsRectItem* hpBar_;            // 血量条
    std::vector<CardItem*> handCards_;     // 手牌
    std::vector<CardItem*> equipments_;    // 装备区
    QGraphicsRectItem* judgmentArea_;      // 判定区
    
public:
    void updatePlayerInfo(const PlayerInfo& info);
    void addHandCard(int cardId);
    void removeHandCard(int cardId);
    void highlightTargetable(bool highlight);
    void showDamageEffect(int damage);
};
```

#### 3.2 卡牌动画系统
```cpp
class CardAnimationManager : public QObject {
    Q_OBJECT
    
private:
    QGraphicsScene* scene_;
    std::queue<std::unique_ptr<CardAnimation>> animationQueue_;
    bool isAnimating_ = false;
    
public:
    // 卡牌移动动画
    void moveCard(CardItem* card, const QPointF& target, int duration = 500);
    
    // 卡牌翻转动画
    void flipCard(CardItem* card, bool faceUp, int duration = 300);
    
    // 卡牌发牌动画
    void dealCards(const std::vector<CardItem*>& cards, 
                  const std::vector<QPointF>& targets, int delay = 100);
    
    // 技能特效动画
    void playSkillEffect(int skillId, const QPointF& center, int duration = 1000);
    
    // 伤害数字动画
    void showDamageNumber(int damage, const QPointF& position);
    
private slots:
    void processNextAnimation();
    void onAnimationFinished();
    
signals:
    void allAnimationsFinished();
};

// 卡牌图形项
class CardItem : public QGraphicsPixmapItem {
    Q_OBJECT
    
private:
    int cardId_;
    Card cardData_;
    bool isSelectable_ = false;
    bool isSelected_ = false;
    QPropertyAnimation* hoverAnimation_;
    
public:
    CardItem(const Card& card, QGraphicsItem* parent = nullptr);
    
    void setSelectable(bool selectable);
    void setSelected(bool selected);
    
protected:
    void mousePressEvent(QGraphicsSceneMouseEvent* event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent* event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent* event) override;
    
signals:
    void cardClicked(int cardId);
    void cardHovered(int cardId);
};
```

#### 3.3 音效和界面优化
```cpp
class AudioManager : public QObject {
    Q_OBJECT
    
private:
    QMediaPlayer* bgmPlayer_;
    QMediaPlayer* sfxPlayer_;
    std::unordered_map<std::string, QString> soundFiles_;
    
public:
    void loadSounds();
    void playBGM(const QString& filename, bool loop = true);
    void playSFX(const QString& soundName);
    void setVolume(float volume);
    void stopAll();
};

class UIThemeManager {
private:
    QString currentTheme_ = "default";
    std::unordered_map<QString, QString> styleSheets_;
    
public:
    void loadTheme(const QString& themeName);
    void applyTheme(QWidget* widget);
    QString getCardImagePath(int cardId) const;
    QString getGeneralImagePath(int generalId) const;
};
```

### 🧪 第四阶段：测试和优化 (Week 7)

#### 4.1 网络优化
- **消息压缩**：对大数据包进行压缩
- **断线重连**：客户端自动重连机制
- **心跳检测**：定期检测连接状态
- **数据同步**：确保游戏状态一致性

#### 4.2 性能优化
- **资源预加载**：提前加载卡牌图片和音效
- **动画优化**：减少不必要的重绘
- **内存管理**：及时释放不用的资源
- **多线程**：网络通信和UI渲染分离

#### 4.3 测试用例设计
```cpp
class GameLogicTest : public QObject {
    Q_OBJECT
    
private slots:
    void testCardPlay();
    void testSkillActivation();
    void testDamageCalculation();
    void testGameEnd();
    void testNetworkProtocol();
};
```

---

## 📊 项目价值和面试亮点

### 技术亮点总结

#### 1. **完整的C/S架构设计**
- 自定义网络协议设计和实现
- 基于NetBox的高性能服务器架构
- 状态同步和数据一致性保证

#### 2. **Qt GUI开发技能**
- 现代化的游戏界面设计
- 复杂的动画系统实现
- 用户交互和体验优化

#### 3. **游戏开发经验**
- 复杂的游戏逻辑实现
- 实时多人游戏同步
- 技能系统和卡牌系统设计

#### 4. **工程化实践**
- 模块化的代码架构
- 完整的测试覆盖
- 资源管理和性能优化

### 面试问答准备

**Q: 为什么选择基于NetBox开发游戏服务器？**
A: NetBox提供了完善的网络框架基础，包括IO多路复用、协议路由、线程池等，让我可以专注于游戏逻辑的实现而不是底层网络编程。同时，NetBox的插件化设计让我可以很容易地扩展游戏协议。

**Q: 如何保证多客户端的游戏状态同步？**
A: 采用服务器权威的设计，所有游戏状态变更都在服务器端计算和验证，然后广播给所有客户端。客户端只负责显示和用户交互，不直接修改游戏状态。

**Q: Qt中如何实现流畅的卡牌动画？**
A: 使用QPropertyAnimation配合QGraphicsView框架，通过属性动画系统实现卡牌的移动、旋转、缩放等效果。同时使用动画队列管理复杂的动画序列。

---

## 🎯 开发时间线

| 周次 | 主要任务 | 预期产出 |
|------|----------|----------|
| **Week 1** | NetBox协议扩展 + 服务器框架 | 可运行的游戏服务器基础 |
| **Week 2** | Qt客户端框架 + 网络通信 | 客户端-服务器连接建立 |
| **Week 3** | 游戏逻辑核心 + 数据结构 | 基本游戏流程实现 |
| **Week 4** | 技能系统 + 卡牌系统 | 完整的游戏规则实现 |
| **Week 5** | UI美化 + 动画系统 | 良好的视觉效果 |
| **Week 6** | 音效 + 用户体验优化 | 完整的游戏体验 |
| **Week 7** | 测试 + 性能优化 + 文档 | 可发布的项目版本 |

---

## 🚀 项目最终成果

完成后您将拥有：

1. **完整的三国杀游戏**：支持多人实时对战
2. **技术展示项目**：体现网络编程、GUI开发、游戏开发等多项技能
3. **丰富的面试素材**：大量的技术细节和设计决策可以展示
4. **可扩展的架构**：可以继续添加新武将、新玩法等

**这样您就有了两个互补的校招项目：**
- **NetBox**：后端技术栈，网络编程能力
- **三国杀游戏**：全栈技术，GUI和游戏开发能力

**准备好开始这个激动人心的项目了吗？需要我详细设计任何特定模块吗？** 🎮 